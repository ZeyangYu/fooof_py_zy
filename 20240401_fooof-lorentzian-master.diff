diff --git a/fooof/__init__.py b/fooof/__init__.py
index 7aca003..6fa1b66 100644
--- a/fooof/__init__.py
+++ b/fooof/__init__.py
@@ -2,6 +2,16 @@
 
 from .version import __version__
 
+# Deprecation of fooof / move to specparam message
+#   Note: this warning is for fooof v1.1 specifically, and should be removed in specparam 2.0
+from warnings import warn, simplefilter
+simplefilter('always')  # make sure user sees it once, on every import
+DEPRECATION_TEXT = ("\nThe `fooof` package is being deprecated and replaced by the "
+    "`specparam` (spectral parameterization) package."
+    "\nThis version of `fooof` (1.1) is fully functional, but will not be further updated."
+    "\nNew projects are recommended to update to using `specparam` (see Changelog for details).")
+warn(DEPRECATION_TEXT, DeprecationWarning, stacklevel=2)
+
 from .bands import Bands
 from .objs import FOOOF, FOOOFGroup
 from .objs.utils import fit_fooof_3d
diff --git a/fooof/analysis/periodic.py b/fooof/analysis/periodic.py
index 7dd3f96..eb618d6 100644
--- a/fooof/analysis/periodic.py
+++ b/fooof/analysis/periodic.py
@@ -21,7 +21,7 @@ def get_band_peak_fm(fm, band, select_highest=True, threshold=None, thresh_param
     select_highest : bool, optional, default: True
         Whether to return single peak (if True) or all peaks within the range found (if False).
         If True, returns the highest power peak within the search range.
-    threshold : float
+    threshold : float, optional
         A minimum threshold value to apply.
     thresh_param : {'PW', 'BW'}
         Which parameter to threshold on. 'PW' is power and 'BW' is bandwidth.
@@ -58,7 +58,7 @@ def get_band_peak_fg(fg, band, threshold=None, thresh_param='PW', attribute='pea
     band : tuple of (float, float)
         Frequency range for the band of interest.
         Defined as: (lower_frequency_bound, upper_frequency_bound).
-    threshold : float
+    threshold : float, optional
         A minimum threshold value to apply.
     thresh_param : {'PW', 'BW'}
         Which parameter to threshold on. 'PW' is power and 'BW' is bandwidth.
@@ -113,7 +113,7 @@ def get_band_peak_group(peak_params, band, n_fits, threshold=None, thresh_param=
         Defined as: (lower_frequency_bound, upper_frequency_bound).
     n_fits : int
         The number of model fits in the FOOOFGroup data.
-    threshold : float
+    threshold : float, optional
         A minimum threshold value to apply.
     thresh_param : {'PW', 'BW'}
         Which parameter to threshold on. 'PW' is power and 'BW' is bandwidth.
@@ -157,7 +157,7 @@ def get_band_peak(peak_params, band, select_highest=True, threshold=None, thresh
     select_highest : bool, optional, default: True
         Whether to return single peak (if True) or all peaks within the range found (if False).
         If True, returns the highest peak within the search range.
-    threshold : float
+    threshold : float, optional
         A minimum threshold value to apply.
     thresh_param : {'PW', 'BW'}
         Which parameter to threshold on. 'PW' is power and 'BW' is bandwidth.
diff --git a/fooof/core/funcs.py b/fooof/core/funcs.py
index e4751c4..249bee0 100644
--- a/fooof/core/funcs.py
+++ b/fooof/core/funcs.py
@@ -40,6 +40,32 @@ def gaussian_function(xs, *params):
 
     return ys
 
+def lorentzian_function(xs, offset, log_knee, exp):
+    """Lorentzian fitting function, for fitting aperiodic component with a 'log knee'.
+
+    NOTE: this function requires linear frequency (not log).
+
+    Parameters
+    ----------
+    xs : 1d array
+        Input x-axis values.
+    offset, log_knee, exp : floats
+        Parameters (offset, knee, exp) that define Lorentzian function:
+        y = offset + log_knee * exp - np.log10(10**(log_knee * exp) + xs**exp
+
+    Returns
+    -------
+    ys : 1d array
+        Output values for lorentzian function.
+    """
+
+    ys = np.zeros_like(xs)
+    fmin = 1 #np.min(xs)
+
+    ys = ys + offset + np.log10(10**(log_knee * exp) + fmin**exp) - np.log10(10**(log_knee * exp) + xs**exp)
+
+    return ys
+
 
 def expo_function(xs, *params):
     """Exponential fitting function, for fitting aperiodic component with a 'knee'.
@@ -198,6 +224,8 @@ def get_ap_func(aperiodic_mode):
         ap_func = expo_nk_function
     elif aperiodic_mode == 'knee':
         ap_func = expo_function
+    elif aperiodic_mode == 'lorentzian':
+        ap_func = lorentzian_function
     else:
         raise ValueError("Requested aperiodic mode not understood.")
 
diff --git a/fooof/core/info.py b/fooof/core/info.py
index 9cd9c3e..dbbb406 100644
--- a/fooof/core/info.py
+++ b/fooof/core/info.py
@@ -77,6 +77,8 @@ def get_ap_indices(aperiodic_mode):
         labels = ('offset', 'exponent')
     elif aperiodic_mode == 'knee':
         labels = ('offset', 'knee', 'exponent')
+    elif aperiodic_mode == 'lorentzian':
+        labels = ('offset', 'log knee', 'exponent')
     else:
         raise ValueError("Aperiodic mode not understood.")
 
@@ -90,7 +92,7 @@ def get_indices(aperiodic_mode):
 
     Parameters
     ----------
-    aperiodic_mode : {'fixed', 'knee'}
+    aperiodic_mode : {'fixed', 'knee', 'lorentzian'}
         Which mode was used for the aperiodic component.
 
     Returns
diff --git a/fooof/core/modutils.py b/fooof/core/modutils.py
index c342a52..0fa49f0 100644
--- a/fooof/core/modutils.py
+++ b/fooof/core/modutils.py
@@ -45,6 +45,38 @@ def safe_import(*args):
     return mod
 
 
+def check_dependency(dep, name):
+    """Decorator that checks if an optional dependency is available.
+
+    Parameters
+    ----------
+    dep : module or False
+        Module, if successfully imported, or boolean (False) if not.
+    name : str
+        Full name of the module, to be printed in message.
+
+    Returns
+    -------
+    wrap : callable
+        The decorated function.
+
+    Raises
+    ------
+    ImportError
+        If the requested dependency is not available.
+    """
+
+    def wrap(func):
+        @wraps(func)
+        def wrapped_func(*args, **kwargs):
+            if not dep:
+                raise ImportError("Optional FOOOF dependency " + name + \
+                                  " is required for this functionality.")
+            return func(*args, **kwargs)
+        return wrapped_func
+    return wrap
+
+
 def docs_drop_param(docstring):
     """Drop the first parameter description for a string representation of a docstring.
 
@@ -148,35 +180,3 @@ def copy_doc_class(source, section='Attributes', add=''):
         return func
 
     return wrapper
-
-
-def check_dependency(dep, name):
-    """Decorator that checks if an optional dependency is available.
-
-    Parameters
-    ----------
-    dep : module or False
-        Module, if successfully imported, or boolean (False) if not.
-    name : str
-        Full name of the module, to be printed in message.
-
-    Returns
-    -------
-    wrap : callable
-        The decorated function.
-
-    Raises
-    ------
-    ImportError
-        If the requested dependency is not available.
-    """
-
-    def wrap(func):
-        @wraps(func)
-        def wrapped_func(*args, **kwargs):
-            if not dep:
-                raise ImportError("Optional FOOOF dependency " + name + \
-                                  " is required for this functionality.")
-            func(*args, **kwargs)
-        return wrapped_func
-    return wrap
diff --git a/fooof/core/reports.py b/fooof/core/reports.py
index 20323b1..bfdf494 100644
--- a/fooof/core/reports.py
+++ b/fooof/core/reports.py
@@ -22,7 +22,7 @@ SAVE_FORMAT = 'pdf'
 ###################################################################################################
 
 @check_dependency(plt, 'matplotlib')
-def save_report_fm(fm, file_name, file_path=None, plt_log=False):
+def save_report_fm(fm, file_name, file_path=None, plt_log=False, add_settings=True, **plot_kwargs):
     """Generate and save out a PDF report for a power spectrum model fit.
 
     Parameters
@@ -35,31 +35,38 @@ def save_report_fm(fm, file_name, file_path=None, plt_log=False):
         Path to directory to save to. If None, saves to current directory.
     plt_log : bool, optional, default: False
         Whether or not to plot the frequency axis in log space.
+    add_settings : bool, optional, default: True
+        Whether to add a print out of the model settings to the end of the report.
+    plot_kwargs : keyword arguments
+        Keyword arguments to pass into the plot method.
     """
 
+    # Define grid settings based on what is to be plotted
+    n_rows = 3 if add_settings else 2
+    height_ratios = [0.5, 1.0, 0.25] if add_settings else [0.45, 1.0]
+
     # Set up outline figure, using gridspec
     _ = plt.figure(figsize=REPORT_FIGSIZE)
-    grid = gridspec.GridSpec(3, 1, height_ratios=[0.45, 1.0, 0.25])
+    grid = gridspec.GridSpec(n_rows, 1, hspace=0.25, height_ratios=height_ratios)
 
     # First - text results
     ax0 = plt.subplot(grid[0])
     results_str = gen_results_fm_str(fm)
     ax0.text(0.5, 0.7, results_str, REPORT_FONT, ha='center', va='center')
     ax0.set_frame_on(False)
-    ax0.set_xticks([])
-    ax0.set_yticks([])
+    ax0.set(xticks=[], yticks=[])
 
     # Second - data plot
     ax1 = plt.subplot(grid[1])
-    fm.plot(plt_log=plt_log, ax=ax1)
+    fm.plot(plt_log=plt_log, ax=ax1, **plot_kwargs)
 
     # Third - FOOOF settings
-    ax2 = plt.subplot(grid[2])
-    settings_str = gen_settings_str(fm, False)
-    ax2.text(0.5, 0.1, settings_str, REPORT_FONT, ha='center', va='center')
-    ax2.set_frame_on(False)
-    ax2.set_xticks([])
-    ax2.set_yticks([])
+    if add_settings:
+        ax2 = plt.subplot(grid[2])
+        settings_str = gen_settings_str(fm, False)
+        ax2.text(0.5, 0.1, settings_str, REPORT_FONT, ha='center', va='center')
+        ax2.set_frame_on(False)
+        ax2.set(xticks=[], yticks=[])
 
     # Save out the report
     plt.savefig(fpath(file_path, fname(file_name, SAVE_FORMAT)))
@@ -67,7 +74,7 @@ def save_report_fm(fm, file_name, file_path=None, plt_log=False):
 
 
 @check_dependency(plt, 'matplotlib')
-def save_report_fg(fg, file_name, file_path=None):
+def save_report_fg(fg, file_name, file_path=None, add_settings=True):
     """Generate and save out a PDF report for a group of power spectrum models.
 
     Parameters
@@ -78,19 +85,26 @@ def save_report_fg(fg, file_name, file_path=None):
         Name to give the saved out file.
     file_path : str, optional
         Path to directory to save to. If None, saves to current directory.
+    add_settings : bool, optional, default: True
+        Whether to add a print out of the model settings to the end of the report.
     """
 
+    # Define grid settings based on what is to be plotted
+    n_rows = 4 if add_settings else 3
+    height_ratios = [1.0, 1.0, 1.0, 0.5] if add_settings else [0.8, 1.0, 1.0]
+
     # Initialize figure
     _ = plt.figure(figsize=REPORT_FIGSIZE)
-    grid = gridspec.GridSpec(3, 2, wspace=0.4, hspace=0.25, height_ratios=[0.8, 1.0, 1.0])
+    grid = gridspec.GridSpec(n_rows, 2, wspace=0.4, hspace=0.25, height_ratios=height_ratios)
 
     # First / top: text results
     ax0 = plt.subplot(grid[0, :])
     results_str = gen_results_fg_str(fg)
     ax0.text(0.5, 0.7, results_str, REPORT_FONT, ha='center', va='center')
     ax0.set_frame_on(False)
-    ax0.set_xticks([])
-    ax0.set_yticks([])
+    ax0.set(xticks=[], yticks=[])
+
+    # Second - data plots
 
     # Aperiodic parameters plot
     ax1 = plt.subplot(grid[1, 0])
@@ -104,6 +118,14 @@ def save_report_fg(fg, file_name, file_path=None):
     ax3 = plt.subplot(grid[2, :])
     plot_fg_peak_cens(fg, ax3)
 
+    # Third - Model settings
+    if add_settings:
+        ax4 = plt.subplot(grid[3, :])
+        settings_str = gen_settings_str(fg, False)
+        ax4.text(0.5, 0.1, settings_str, REPORT_FONT, ha='center', va='center')
+        ax4.set_frame_on(False)
+        ax4.set(xticks=[], yticks=[])
+
     # Save out the report
     plt.savefig(fpath(file_path, fname(file_name, SAVE_FORMAT)))
     plt.close()
diff --git a/fooof/core/strings.py b/fooof/core/strings.py
index ad0e34c..6646bad 100644
--- a/fooof/core/strings.py
+++ b/fooof/core/strings.py
@@ -36,7 +36,7 @@ def gen_width_warning_str(freq_res, bwl):
     output = '\n'.join([
         '',
         'FOOOF WARNING: Lower-bound peak width limit is < or ~= the frequency resolution: ' + \
-            '{:1.2f} <= {:1.2f}'.format(freq_res, bwl),
+            '{:1.2f} <= {:1.2f}'.format(bwl, freq_res),
         '\tLower bounds below frequency-resolution have no effect ' + \
         '(effective lower bound is the frequency resolution).',
         '\tToo low a limit may lead to overfitting noise as small bandwidth peaks.',
@@ -297,8 +297,10 @@ def gen_results_fm_str(fm, concise=False):
         '',
 
         # Aperiodic parameters
-        ('Aperiodic Parameters (offset, ' + ('knee, ' if fm.aperiodic_mode == 'knee' else '') + \
-         'exponent): '),
+        
+        ('Aperiodic Parameters (offset, knee, exponent): ' if fm.aperiodic_mode == 'knee' else \
+         'Aperiodic Parameters (offset, log knee, exponent): ' if fm.aperiodic_mode == 'lorentzian' else \
+            'Aperiodic Parameters (offset, exponent): '),
         ', '.join(['{:2.4f}'] * len(fm.aperiodic_params_)).format(*fm.aperiodic_params_),
         '',
 
diff --git a/fooof/core/utils.py b/fooof/core/utils.py
index f0fcdb5..3b50e44 100644
--- a/fooof/core/utils.py
+++ b/fooof/core/utils.py
@@ -13,13 +13,13 @@ def group_three(vec):
 
     Parameters
     ----------
-    vec : 1d array
-        Array of items to group by 3. Length of array must be divisible by three.
+    vec : list or 1d array
+        List or array of items to group by 3. Length of array must be divisible by three.
 
     Returns
     -------
-    list of list
-        List of lists, each with three items.
+    array or list of list
+        Array or list of lists, each with three items. Output type will match input type.
 
     Raises
     ------
@@ -30,7 +30,11 @@ def group_three(vec):
     if len(vec) % 3 != 0:
         raise ValueError("Wrong size array to group by three.")
 
-    return [list(vec[ii:ii+3]) for ii in range(0, len(vec), 3)]
+    # Reshape, if an array, as it's faster, otherwise asssume lise
+    if isinstance(vec, np.ndarray):
+        return np.reshape(vec, (-1, 3))
+    else:
+        return [list(vec[ii:ii+3]) for ii in range(0, len(vec), 3)]
 
 
 def nearest_ind(array, value):
diff --git a/fooof/data/conversions.py b/fooof/data/conversions.py
new file mode 100644
index 0000000..f2dbfeb
--- /dev/null
+++ b/fooof/data/conversions.py
@@ -0,0 +1,106 @@
+"""Conversion functions for organizing model results into alternate representations."""
+
+import numpy as np
+
+from fooof import Bands
+from fooof.core.funcs import infer_ap_func
+from fooof.core.info import get_ap_indices, get_peak_indices
+from fooof.core.modutils import safe_import, check_dependency
+from fooof.analysis.periodic import get_band_peak
+
+pd = safe_import('pandas')
+
+###################################################################################################
+###################################################################################################
+
+def model_to_dict(fit_results, peak_org):
+    """Convert model fit results to a dictionary.
+
+    Parameters
+    ----------
+    fit_results : FOOOFResults
+        Results of a model fit.
+    peak_org : int or Bands
+        How to organize peaks.
+        If int, extracts the first n peaks.
+        If Bands, extracts peaks based on band definitions.
+
+    Returns
+    -------
+    dict
+        Model results organized into a dictionary.
+    """
+
+    fr_dict = {}
+
+    # aperiodic parameters
+    for label, param in zip(get_ap_indices(infer_ap_func(fit_results.aperiodic_params)),
+                            fit_results.aperiodic_params):
+        fr_dict[label] = param
+
+    # periodic parameters
+    peaks = fit_results.peak_params
+
+    if isinstance(peak_org, int):
+
+        if len(peaks) < peak_org:
+            nans = [np.array([np.nan] * 3) for ind in range(peak_org-len(peaks))]
+            peaks = np.vstack((peaks, nans))
+
+        for ind, peak in enumerate(peaks[:peak_org, :]):
+            for pe_label, pe_param in zip(get_peak_indices(), peak):
+                fr_dict[pe_label.lower() + '_' + str(ind)] = pe_param
+
+    elif isinstance(peak_org, Bands):
+        for band, f_range in peak_org:
+            for label, param in zip(get_peak_indices(), get_band_peak(peaks, f_range)):
+                fr_dict[band + '_' + label.lower()] = param
+
+    # goodness-of-fit metrics
+    fr_dict['error'] = fit_results.error
+    fr_dict['r_squared'] = fit_results.r_squared
+
+    return fr_dict
+
+@check_dependency(pd, 'pandas')
+def model_to_dataframe(fit_results, peak_org):
+    """Convert model fit results to a dataframe.
+
+    Parameters
+    ----------
+    fit_results : FOOOFResults
+        Results of a model fit.
+    peak_org : int or Bands
+        How to organize peaks.
+        If int, extracts the first n peaks.
+        If Bands, extracts peaks based on band definitions.
+
+    Returns
+    -------
+    pd.Series
+        Model results organized into a dataframe.
+    """
+
+    return pd.Series(model_to_dict(fit_results, peak_org))
+
+
+@check_dependency(pd, 'pandas')
+def group_to_dataframe(fit_results, peak_org):
+    """Convert a group of model fit results into a dataframe.
+
+    Parameters
+    ----------
+    fit_results : list of FOOOFResults
+        List of FOOOFResults objects.
+    peak_org : int or Bands
+        How to organize peaks.
+        If int, extracts the first n peaks.
+        If Bands, extracts peaks based on band definitions.
+
+    Returns
+    -------
+    pd.DataFrame
+        Model results organized into a dataframe.
+    """
+
+    return pd.DataFrame([model_to_dataframe(f_res, peak_org) for f_res in fit_results])
diff --git a/fooof/objs/fit.py b/fooof/objs/fit.py
index fba745d..a49aefe 100644
--- a/fooof/objs/fit.py
+++ b/fooof/objs/fit.py
@@ -28,8 +28,6 @@ _ap_bounds : tuple of tuple of float
     Upper and lower bounds on fitting aperiodic component.
 _cf_bound : float
     Parameter bounds for center frequency when fitting gaussians.
-_bw_std_edge : float
-    Bandwidth threshold for edge rejection of peaks, in units of gaussian standard deviation.
 _gauss_overlap_thresh : float
     Degree of overlap (in units of standard deviation) between gaussian guesses to drop one.
 _gauss_std_limits : list of [float, float]
@@ -59,7 +57,8 @@ from copy import deepcopy
 
 import numpy as np
 from numpy.linalg import LinAlgError
-from scipy.optimize import curve_fit
+from scipy.optimize import curve_fit, minimize
+import scipy.stats
 
 from fooof.core.items import OBJ_DESC
 from fooof.core.info import get_indices
@@ -67,22 +66,32 @@ from fooof.core.io import save_fm, load_json
 from fooof.core.reports import save_report_fm
 from fooof.core.modutils import copy_doc_func_to_method
 from fooof.core.utils import group_three, check_array_dim
-from fooof.core.funcs import gaussian_function, get_ap_func, infer_ap_func
+from fooof.core.funcs import gaussian_function, get_ap_func, lorentzian_function, infer_ap_func
 from fooof.core.errors import (FitError, NoModelError, DataError,
                                NoDataError, InconsistentDataError)
 from fooof.core.strings import (gen_settings_str, gen_results_fm_str,
                                 gen_issue_str, gen_width_warning_str)
 
 from fooof.plts.fm import plot_fm
-from fooof.plts.style import style_spectrum_plot
 from fooof.utils.data import trim_spectrum
 from fooof.utils.params import compute_gauss_std
 from fooof.data import FOOOFResults, FOOOFSettings, FOOOFMetaData
+from fooof.data.conversions import model_to_dataframe
 from fooof.sim.gen import gen_freqs, gen_aperiodic, gen_periodic, gen_model
 
 ###################################################################################################
 ###################################################################################################
 
+def get_negative_AUC(params, fmin):
+    params_reshape = params.reshape(int(len(params)/3), 3)
+    AUC = 0
+    num_peaks = params_reshape.shape[0]
+    for i in range(num_peaks): 
+        mu, height, sigma = params_reshape[i, 0], params_reshape[i, 1], params_reshape[i, 2]
+        AUC += height * scipy.stats.norm(mu, sigma).cdf(fmin)
+
+    return AUC
+
 class FOOOF():
     """Model a physiological power spectrum as a combination of aperiodic and periodic components.
 
@@ -98,11 +107,13 @@ class FOOOF():
     max_n_peaks : int, optional, default: inf
         Maximum number of peaks to fit.
     min_peak_height : float, optional, default: 0
-        Absolute threshold for detecting peaks, in units of the input data.
+        Absolute threshold for detecting peaks.
+        This threshold is defined in absolute units of the power spectrum (log power).
     peak_threshold : float, optional, default: 2.0
-        Relative threshold for detecting peaks, in units of standard deviation of the input data.
-    aperiodic_mode : {'fixed', 'knee'}
-        Which approach to take for fitting the aperiodic component.
+        Relative threshold for detecting peaks.
+        This threshold is defined in relative units of the power spectrum (standard deviation).
+    aperiodic_mode : {'fixed', 'knee', 'lorentzian'}
+        Which approach to take for fitting the aperiodic component.,
     verbose : bool, optional, default: True
         Verbosity mode. If True, prints out warnings and general status updates.
 
@@ -155,7 +166,7 @@ class FOOOF():
     # pylint: disable=attribute-defined-outside-init
 
     def __init__(self, peak_width_limits=(0.5, 12.0), max_n_peaks=np.inf, min_peak_height=0.0,
-                 peak_threshold=2.0, aperiodic_mode='fixed', verbose=True):
+                 peak_threshold=2.0, aperiodic_mode='fixed', regularization_weight = 0, verbose=True):
         """Initialize object with desired settings."""
 
         # Set input settings
@@ -173,30 +184,44 @@ class FOOOF():
         # Guess parameters for aperiodic fitting, [offset, knee, exponent]
         #   If offset guess is None, the first value of the power spectrum is used as offset guess
         #   If exponent guess is None, the abs(log-log slope) of first & last points is used
-        self._ap_guess = (None, 0, None)
+        if aperiodic_mode in ['fixed', 'knee']:
+            self._ap_guess = (None, 0, None)
+        elif aperiodic_mode == 'lorentzian':
+            self._ap_guess = (None, 1, None)
         # Bounds for aperiodic fitting, as: ((offset_low_bound, knee_low_bound, exp_low_bound),
         #                                    (offset_high_bound, knee_high_bound, exp_high_bound))
         # By default, aperiodic fitting is unbound, but can be restricted here, if desired
         #   Even if fitting without knee, leave bounds for knee (they are dropped later)
-        self._ap_bounds = ((-np.inf, -np.inf, -np.inf), (np.inf, np.inf, np.inf))
+        if aperiodic_mode in ['fixed', 'knee']:
+            self._ap_bounds = ((-np.inf, -np.inf, -np.inf), (np.inf, np.inf, np.inf))
+        #   Different format because these bounds will go to minimize rather than curvefit
+        elif aperiodic_mode == 'lorentzian':
+            self._ap_bounds =  ((None, None), (-1, 3), (None, None))
         # Threshold for how far a peak has to be from edge to keep.
         #   This is defined in units of gaussian standard deviation
-        self._bw_std_edge = 1.0
+        self.bw_std_edge = 1.0
         # Degree of overlap between gaussians for one to be dropped
         #   This is defined in units of gaussian standard deviation
         self._gauss_overlap_thresh = 0.75
         # Parameter bounds for center frequency when fitting gaussians, in terms of +/- std dev
         self._cf_bound = 1.5
+        # Lowest captured frequency in spectrum in Hz - Used as upper bound when integrating for negative AUC for regularization
+        self.fmin = 1
         # The maximum number of calls to the curve fitting function
         self._maxfev = 5000
         # The error metric to calculate, post model fitting. See `_calc_error` for options
         #   Note: this is for checking error post fitting, not an objective function for fitting
         self._error_metric = 'MAE'
+        # Regularization if Lorentzian Aperiodic Mode is used. Default - not implemented since regulatization = 0
+        self.regularization_weight = regularization_weight
 
         ## RUN MODES
         # Set default debug mode - controls if an error is raised if model fitting is unsuccessful
         self._debug = False
-        # Set default check data mode - controls if an error is raised if NaN / Inf data are added
+        # Set default data checking modes - controls which checks get run on input data
+        #   check_freqs: check the frequency values, and raises an error for uneven spacing
+        self._check_freqs = False
+        #   check_data: checks the power values and raises an error for any NaN / Inf values
         self._check_data = True
 
         # Set internal settings, based on inputs, and initialize data & results attributes
@@ -247,7 +272,7 @@ class FOOOF():
 
             # Bandwidth limits are given in 2-sided peak bandwidth
             #   Convert to gaussian std parameter limits
-            self._gauss_std_limits = tuple([bwl / 2 for bwl in self.peak_width_limits])
+            self._gauss_std_limits = tuple(bwl / 2 for bwl in self.peak_width_limits)
 
         # Otherwise, assume settings are unknown (have been cleared) and set to None
         else:
@@ -290,7 +315,58 @@ class FOOOF():
             self._spectrum_peak_rm = None
             self._ap_fit = None
             self._peak_fit = None
+    
+    def negative_AUC(self):
+        AUC = 0
+        num_peaks = self.gaussian_params_.shape[0]
+        for i in range(num_peaks): 
+            mu, height, sigma = self.gaussian_params_[i, 0], self.gaussian_params_[i, 1], self.gaussian_params_[i, 2]
+            AUC += height * scipy.stats.norm(mu, sigma).cdf(self.fmin)
+        
+        return AUC
+    
+
+    def aperiodic_regression(self, func, X, y, guess, reg_weight = 1):
+        """
+        args:
+            func: aperiodic model
+            X: frequencies vector (1D vector)
+            y: Observed power spectra (1D vector)
+            guess: initial guess of parameters (1d, length 3)
+            reg_weight: weight of regularization term - negative AUC
+
+        return: trained parameters
+        """
+        def cost(ap_params, reg_weight = 1):  # simply use globally defined x and y
+            offset, knee, exp = ap_params
+            model = func(X, offset, knee, exp)
+            return np.mean((model - y)**2) #+ reg_weight * self.negative_AUC() 
+        
+        res = minimize(cost, guess, reg_weight, bounds = self._ap_bounds, 
+                                                options = {'maxiter': self._maxfev})                      
+
+        return res.x
+    
+    def gaussian_regression(self, X, y, params, reg_weight = 1, bounds = None):
+        """
+        args:
+            X: frequencies vector (1D vector)
+            y: Observed power spectra (1D vector)
+            guess: initial guess of parameters (1d, of variable length, multiple of 3)
+            reg_weight: weight of regularization term - negative AUC
 
+        return: trained parameters
+        """
+
+        def cost(params, reg_weight = 1):  # simply use globally defined x and y
+            model = gaussian_function(X, *params)
+            return np.mean((model - y)**2) + reg_weight * get_negative_AUC(params, self.fmin) 
+            #return np.mean((model - y)**2) + reg_weight * self.negative_AUC() 
+        
+        res = minimize(cost, x0 = params, args = reg_weight, bounds = bounds, 
+                                                options = {'maxiter': self._maxfev})
+
+        return res.x
 
     def add_data(self, freqs, power_spectrum, freq_range=None, clear_results=True):
         """Add data (frequencies, and power spectrum values) to the current object.
@@ -373,7 +449,8 @@ class FOOOF():
         self._check_loaded_results(fooof_result._asdict())
 
 
-    def report(self, freqs=None, power_spectrum=None, freq_range=None, plt_log=False):
+    def report(self, freqs=None, power_spectrum=None, freq_range=None,
+               plt_log=False, **plot_kwargs):
         """Run model fit, and display a report, which includes a plot, and printed results.
 
         Parameters
@@ -387,14 +464,15 @@ class FOOOF():
             If not provided, fits across the entire given range.
         plt_log : bool, optional, default: False
             Whether or not to plot the frequency axis in log space.
+        **plot_kwargs
+            Keyword arguments to pass into the plot method.
 
         Notes
         -----
         Data is optional, if data has already been added to the object.
         """
-
         self.fit(freqs, power_spectrum, freq_range)
-        self.plot(plt_log=plt_log)
+        self.plot(plt_log=plt_log, **plot_kwargs)
         self.print_results(concise=False)
 
 
@@ -452,7 +530,7 @@ class FOOOF():
 
             # Fit the aperiodic component
             self.aperiodic_params_ = self._robust_ap_fit(self.freqs, self.power_spectrum)
-            self._ap_fit = gen_aperiodic(self.freqs, self.aperiodic_params_)
+            self._ap_fit = gen_aperiodic(self.freqs, self.aperiodic_params_, self.aperiodic_mode)
 
             # Flatten the power spectrum using fit aperiodic fit
             self._spectrum_flat = self.power_spectrum - self._ap_fit
@@ -470,7 +548,7 @@ class FOOOF():
             # Run final aperiodic fit on peak-removed power spectrum
             #   This overwrites previous aperiodic fit, and recomputes the flattened spectrum
             self.aperiodic_params_ = self._simple_ap_fit(self.freqs, self._spectrum_peak_rm)
-            self._ap_fit = gen_aperiodic(self.freqs, self.aperiodic_params_)
+            self._ap_fit = gen_aperiodic(self.freqs, self.aperiodic_params_, self.aperiodic_mode)
             self._spectrum_flat = self.power_spectrum - self._ap_fit
 
             # Create full power_spectrum model fit
@@ -586,9 +664,7 @@ class FOOOF():
 
         Notes
         -----
-        For further description of the data you can extract, check the FOOOFResults documentation.
-
-        If there is no data on periodic features, this method will return NaN.
+        If there are no fit peak (no peak parameters), this method will return NaN.
         """
 
         if not self.has_model:
@@ -635,18 +711,20 @@ class FOOOF():
     @copy_doc_func_to_method(plot_fm)
     def plot(self, plot_peaks=None, plot_aperiodic=True, plt_log=False,
              add_legend=True, save_fig=False, file_name=None, file_path=None,
-             ax=None, plot_style=style_spectrum_plot,
-             data_kwargs=None, model_kwargs=None, aperiodic_kwargs=None, peak_kwargs=None):
+             ax=None, data_kwargs=None, model_kwargs=None,
+             aperiodic_kwargs=None, peak_kwargs=None, **plot_kwargs):
 
-        plot_fm(self, plot_peaks, plot_aperiodic, plt_log, add_legend,
-                save_fig, file_name, file_path, ax, plot_style,
-                data_kwargs, model_kwargs, aperiodic_kwargs, peak_kwargs)
+        plot_fm(self, plot_peaks=plot_peaks, plot_aperiodic=plot_aperiodic, plt_log=plt_log,
+                add_legend=add_legend, save_fig=save_fig, file_name=file_name,
+                file_path=file_path, ax=ax, data_kwargs=data_kwargs, model_kwargs=model_kwargs,
+                aperiodic_kwargs=aperiodic_kwargs, peak_kwargs=peak_kwargs, **plot_kwargs)
 
 
     @copy_doc_func_to_method(save_report_fm)
-    def save_report(self, file_name, file_path=None, plt_log=False):
+    def save_report(self, file_name, file_path=None, plt_log=False,
+                    add_settings=True, **plot_kwargs):
 
-        save_report_fm(self, file_name, file_path, plt_log)
+        save_report_fm(self, file_name, file_path, plt_log, add_settings, **plot_kwargs)
 
 
     @copy_doc_func_to_method(save_fm)
@@ -716,6 +794,25 @@ class FOOOF():
         self._check_data = check_data
 
 
+    def to_df(self, peak_org):
+        """Convert and extract the model results as a pandas object.
+
+        Parameters
+        ----------
+        peak_org : int or Bands
+            How to organize peaks.
+            If int, extracts the first n peaks.
+            If Bands, extracts peaks based on band definitions.
+
+        Returns
+        -------
+        pd.Series
+            Model results organized into a pandas object.
+        """
+
+        return model_to_dataframe(self.get_results(), peak_org)
+
+
     def _check_width_limits(self):
         """Check and warn about peak width limits / frequency resolution interaction."""
 
@@ -743,17 +840,19 @@ class FOOOF():
         # Get the guess parameters and/or calculate from the data, as needed
         #   Note that these are collected as lists, to concatenate with or without knee later
         off_guess = [power_spectrum[0] if not self._ap_guess[0] else self._ap_guess[0]]
-        kne_guess = [self._ap_guess[1]] if self.aperiodic_mode == 'knee' else []
-        exp_guess = [np.abs(self.power_spectrum[-1] - self.power_spectrum[0] /
-                            np.log10(self.freqs[-1]) - np.log10(self.freqs[0]))
+        kne_guess = [self._ap_guess[1]] if self.aperiodic_mode in ['knee', 'lorentzian'] else []
+        exp_guess = [np.abs((self.power_spectrum[-1] - self.power_spectrum[0]) /
+                            (np.log10(self.freqs[-1]) - np.log10(self.freqs[0])))
                      if not self._ap_guess[2] else self._ap_guess[2]]
 
         # Get bounds for aperiodic fitting, dropping knee bound if not set to fit knee
-        ap_bounds = self._ap_bounds if self.aperiodic_mode == 'knee' \
-            else tuple(bound[0::2] for bound in self._ap_bounds)
+        if self.aperiodic_mode == 'fixed':
+            ap_bounds = tuple(bound[0::2] for bound in self._ap_bounds)
+        elif self.aperiodic_mode in ['knee', 'lorentzian']:
+            ap_bounds = self._ap_bounds 
 
         # Collect together guess parameters
-        guess = np.array([off_guess + kne_guess + exp_guess])
+        guess = np.array(off_guess + kne_guess + exp_guess)
 
         # Ignore warnings that are raised in curve_fit
         #   A runtime warning can occur while exploring parameters in curve fitting
@@ -762,12 +861,18 @@ class FOOOF():
         try:
             with warnings.catch_warnings():
                 warnings.simplefilter("ignore")
-                aperiodic_params, _ = curve_fit(get_ap_func(self.aperiodic_mode),
-                                                freqs, power_spectrum, p0=guess,
-                                                maxfev=self._maxfev, bounds=ap_bounds)
-        except RuntimeError:
-            raise FitError("Model fitting failed due to not finding parameters in "
-                           "the simple aperiodic component fit.")
+                if self.aperiodic_mode in ['fixed', 'knee']:
+                    aperiodic_params, _ = curve_fit(get_ap_func(self.aperiodic_mode),
+                                                    freqs, power_spectrum, p0=guess,
+                                                    maxfev=self._maxfev, bounds=ap_bounds)
+                elif self.aperiodic_mode == 'lorentzian':
+                    aperiodic_params = self.aperiodic_regression(lorentzian_function,
+                                                    freqs, power_spectrum, np.array(guess),
+                                                    self.regularization_weight)
+        except RuntimeError as excp:
+            error_msg = ("Model fitting failed due to not finding parameters in "
+                         "the simple aperiodic component fit.")
+            raise FitError(error_msg) from excp
 
         return aperiodic_params
 
@@ -795,7 +900,7 @@ class FOOOF():
 
         # Do a quick, initial aperiodic fit
         popt = self._simple_ap_fit(freqs, power_spectrum)
-        initial_fit = gen_aperiodic(freqs, popt)
+        initial_fit = gen_aperiodic(freqs, popt, self.aperiodic_mode)
 
         # Flatten power_spectrum based on initial aperiodic fit
         flatspec = power_spectrum - initial_fit
@@ -810,23 +915,32 @@ class FOOOF():
         spectrum_ignore = power_spectrum[perc_mask]
 
         # Get bounds for aperiodic fitting, dropping knee bound if not set to fit knee
-        ap_bounds = self._ap_bounds if self.aperiodic_mode == 'knee' \
-            else tuple(bound[0::2] for bound in self._ap_bounds)
+        if self.aperiodic_mode == 'fixed':
+            ap_bounds = tuple(bound[0::2] for bound in self._ap_bounds)
+        elif self.aperiodic_mode in ['knee', 'lorentzian']:
+            ap_bounds = self._ap_bounds 
 
         # Second aperiodic fit - using results of first fit as guess parameters
         #  See note in _simple_ap_fit about warnings
         try:
             with warnings.catch_warnings():
                 warnings.simplefilter("ignore")
-                aperiodic_params, _ = curve_fit(get_ap_func(self.aperiodic_mode),
-                                                freqs_ignore, spectrum_ignore, p0=popt,
-                                                maxfev=self._maxfev, bounds=ap_bounds)
-        except RuntimeError:
-            raise FitError("Model fitting failed due to not finding "
-                           "parameters in the robust aperiodic fit.")
-        except TypeError:
-            raise FitError("Model fitting failed due to sub-sampling "
-                           "in the robust aperiodic fit.")
+                if self.aperiodic_mode in ['fixed', 'knee']:
+                    aperiodic_params, _ = curve_fit(get_ap_func(self.aperiodic_mode),
+                                                    freqs_ignore, spectrum_ignore, p0=popt,
+                                                    maxfev=self._maxfev, bounds=ap_bounds)
+                elif self.aperiodic_mode == 'lorentzian':
+                    aperiodic_params = self.aperiodic_regression(lorentzian_function,
+                                                    freqs_ignore, spectrum_ignore, popt,
+                                                    self.regularization_weight)
+        except RuntimeError as excp:
+            error_msg = ("Model fitting failed due to not finding "
+                         "parameters in the robust aperiodic fit.")
+            raise FitError(error_msg) from excp
+        except TypeError as excp:
+            error_msg = ("Model fitting failed due to sub-sampling "
+                         "in the robust aperiodic fit.")
+            raise FitError(error_msg) from excp
 
         return aperiodic_params
 
@@ -955,23 +1069,43 @@ class FOOOF():
 
         # Unpacks the embedded lists into flat tuples
         #   This is what the fit function requires as input
-        gaus_param_bounds = (tuple([item for sublist in lo_bound for item in sublist]),
-                             tuple([item for sublist in hi_bound for item in sublist]))
+        if self.aperiodic_mode in ['fixed', 'knee']:
+            gaus_param_bounds = (tuple(item for sublist in lo_bound for item in sublist),
+                                tuple(item for sublist in hi_bound for item in sublist))
+        elif self.aperiodic_mode == 'lorentzian':
+            lo_bound_flatten = np.array(lo_bound).flatten()
+            hi_bound_flatten = np.array(hi_bound).flatten()
+            gaus_param_bounds = []
+            for i in range(len(lo_bound_flatten)):
+                lo_bound_oi = lo_bound_flatten[i]
+                hi_bound_oi = hi_bound_flatten[i]
+                if lo_bound_oi in [np.inf, -np.inf]:
+                    lo_bound_oi = None
+                if hi_bound_oi in [np.inf, -np.inf]:
+                    hi_bound_oi = None
+                gaus_param_bounds.append((lo_bound_oi, hi_bound_oi))
 
         # Flatten guess, for use with curve fit
         guess = np.ndarray.flatten(guess)
 
         # Fit the peaks
         try:
-            gaussian_params, _ = curve_fit(gaussian_function, self.freqs, self._spectrum_flat,
-                                           p0=guess, maxfev=self._maxfev, bounds=gaus_param_bounds)
-        except RuntimeError:
-            raise FitError("Model fitting failed due to not finding "
-                           "parameters in the peak component fit.")
-        except LinAlgError:
-            raise FitError("Model fitting failed due to a LinAlgError during peak fitting. "
-                           "This can happen with settings that are too liberal, leading, "
-                           "to a large number of guess peaks that cannot be fit together.")
+            if self.aperiodic_mode in ['fixed', 'knee']:
+                gaussian_params, _ = curve_fit(gaussian_function, self.freqs, self._spectrum_flat,
+                                            p0=guess, maxfev=self._maxfev, bounds=gaus_param_bounds)
+            elif self.aperiodic_mode == 'lorentzian':
+                gaussian_params = self.gaussian_regression(self.freqs, self._spectrum_flat, 
+                                                        list(guess), self.regularization_weight, 
+                                                        tuple(gaus_param_bounds),)
+        except RuntimeError as excp:
+            error_msg = ("Model fitting failed due to not finding "
+                         "parameters in the peak component fit.")
+            raise FitError(error_msg) from excp
+        except LinAlgError as excp:
+            error_msg = ("Model fitting failed due to a LinAlgError during peak fitting. "
+                         "This can happen with settings that are too liberal, leading, "
+                         "to a large number of guess peaks that cannot be fit together.")
+            raise FitError(error_msg) from excp
 
         # Re-organize params into 2d matrix
         gaussian_params = np.array(group_three(gaussian_params))
@@ -1007,18 +1141,16 @@ class FOOOF():
         with `freqs`, `fooofed_spectrum_` and `_ap_fit` all required to be available.
         """
 
-        peak_params = np.empty([0, 3])
+        peak_params = np.empty((len(gaus_params), 3))
 
         for ii, peak in enumerate(gaus_params):
 
             # Gets the index of the power_spectrum at the frequency closest to the CF of the peak
-            ind = min(range(len(self.freqs)), key=lambda ii: abs(self.freqs[ii] - peak[0]))
+            ind = np.argmin(np.abs(self.freqs - peak[0]))
 
             # Collect peak parameter data
-            peak_params = np.vstack((peak_params,
-                                     [peak[0],
-                                      self.fooofed_spectrum_[ind] - self._ap_fit[ind],
-                                      peak[2] * 2]))
+            peak_params[ii] = [peak[0], self.fooofed_spectrum_[ind] - self._ap_fit[ind],
+                               peak[2] * 2]
 
         return peak_params
 
@@ -1037,8 +1169,8 @@ class FOOOF():
             Guess parameters for gaussian peak fits. Shape: [n_peaks, 3].
         """
 
-        cf_params = [item[0] for item in guess]
-        bw_params = [item[2] * self._bw_std_edge for item in guess]
+        cf_params = guess[:, 0]
+        bw_params = guess[:, 2] * self.bw_std_edge
 
         # Check if peaks within drop threshold from the edge of the frequency range
         keep_peak = \
@@ -1112,7 +1244,10 @@ class FOOOF():
         Parameters
         ----------
         metric : {'MAE', 'MSE', 'RMSE'}, optional
-            Which error measure to calculate.
+            Which error measure to calculate:
+            * 'MAE' : mean absolute error
+            * 'MSE' : mean squared error
+            * 'RMSE' : root mean squared error
 
         Raises
         ------
@@ -1137,8 +1272,8 @@ class FOOOF():
             self.error_ = np.sqrt(((self.power_spectrum - self.fooofed_spectrum_) ** 2).mean())
 
         else:
-            msg = "Error metric '{}' not understood or not implemented.".format(metric)
-            raise ValueError(msg)
+            error_msg = "Error metric '{}' not understood or not implemented.".format(metric)
+            raise ValueError(error_msg)
 
 
     def _prepare_data(self, freqs, power_spectrum, freq_range, spectra_dim=1):
@@ -1220,13 +1355,22 @@ class FOOOF():
         # Log power values
         power_spectrum = np.log10(power_spectrum)
 
+        ## Data checks - run checks on inputs based on check modes
+
+        if self._check_freqs:
+            # Check if the frequency data is unevenly spaced, and raise an error if so
+            freq_diffs = np.diff(freqs)
+            if not np.all(np.isclose(freq_diffs, freq_res)):
+                raise DataError("The input frequency values are not evenly spaced. "
+                                "The model expects equidistant frequency values in linear space.")
         if self._check_data:
             # Check if there are any infs / nans, and raise an error if so
             if np.any(np.isinf(power_spectrum)) or np.any(np.isnan(power_spectrum)):
-                raise DataError("The input power spectra data, after logging, contains NaNs or Infs. "
-                                "This will cause the fitting to fail. "
-                                "One reason this can happen is if inputs are already logged. "
-                                "Inputs data should be in linear spacing, not log.")
+                error_msg = ("The input power spectra data, after logging, contains NaNs or Infs. "
+                             "This will cause the fitting to fail. "
+                             "One reason this can happen is if inputs are already logged. "
+                             "Inputs data should be in linear spacing, not log.")
+                raise DataError(error_msg)
 
         return freqs, power_spectrum, freq_range, freq_res
 
@@ -1297,4 +1441,4 @@ class FOOOF():
         """Regenerate model fit from parameters."""
 
         self.fooofed_spectrum_, self._peak_fit, self._ap_fit = gen_model(
-            self.freqs, self.aperiodic_params_, self.gaussian_params_, return_components=True)
+            self.freqs, self.aperiodic_params_, self.aperiodic_mode, self.gaussian_params_, return_components=True)
diff --git a/fooof/objs/group.py b/fooof/objs/group.py
index 91abcee..f5d33ec 100644
--- a/fooof/objs/group.py
+++ b/fooof/objs/group.py
@@ -21,6 +21,7 @@ from fooof.core.reports import save_report_fg
 from fooof.core.strings import gen_results_fg_str
 from fooof.core.io import save_fg, load_jsonlines
 from fooof.core.modutils import copy_doc_func_to_method, safe_import
+from fooof.data.conversions import group_to_dataframe
 
 ###################################################################################################
 ###################################################################################################
@@ -43,7 +44,7 @@ class FOOOFGroup(FOOOF):
         Absolute threshold for detecting peaks, in units of the input data.
     peak_threshold : float, optional, default: 2.0
         Relative threshold for detecting peaks, in units of standard deviation of the input data.
-    aperiodic_mode : {'fixed', 'knee'}
+    aperiodic_mode : {'fixed', 'knee', 'lorentzian'}
         Which approach to take for fitting the aperiodic component.
     verbose : bool, optional, default: True
         Verbosity mode. If True, prints out warnings and general status updates.
@@ -354,7 +355,8 @@ class FOOOFGroup(FOOOF):
 
         Notes
         -----
-        For further description of the data you can extract, check the FOOOFResults documentation.
+        When extracting peak information ('peak_params' or 'gaussian_params'), an additional column
+        is appended to the returned array, indicating the index of the model that the peak came from.
         """
 
         if not self.has_model:
@@ -375,8 +377,11 @@ class FOOOFGroup(FOOOF):
         # As a special case, peak_params are pulled out in a way that appends
         #  an extra column, indicating which FOOOF run each peak comes from
         if name in ('peak_params', 'gaussian_params'):
-            out = np.array([np.insert(getattr(data, name), 3, index, axis=1)
-                            for index, data in enumerate(self.group_results)])
+
+            # Collect peak data, appending the index of the model it comes from
+            out = np.vstack([np.insert(getattr(data, name), 3, index, axis=1)
+                             for index, data in enumerate(self.group_results)])
+
             # This updates index to grab selected column, and the last column
             #  This last column is the 'index' column (FOOOF object source)
             if col is not None:
@@ -384,12 +389,6 @@ class FOOOFGroup(FOOOF):
         else:
             out = np.array([getattr(data, name) for data in self.group_results])
 
-        # Some data can end up as a list of separate arrays
-        #   If so, concatenate it all into one 2d array
-        if isinstance(out[0], np.ndarray):
-            out = np.concatenate([arr.reshape(1, len(arr)) \
-                if arr.ndim == 1 else arr for arr in out], 0)
-
         # Select out a specific column, if requested
         if col is not None:
             out = out[:, col]
@@ -398,15 +397,15 @@ class FOOOFGroup(FOOOF):
 
 
     @copy_doc_func_to_method(plot_fg)
-    def plot(self, save_fig=False, file_name=None, file_path=None):
+    def plot(self, save_fig=False, file_name=None, file_path=None, **plot_kwargs):
 
-        plot_fg(self, save_fig, file_name, file_path)
+        plot_fg(self, save_fig=save_fig, file_name=file_name, file_path=file_path, **plot_kwargs)
 
 
     @copy_doc_func_to_method(save_report_fg)
-    def save_report(self, file_name, file_path=None):
+    def save_report(self, file_name, file_path=None, add_settings=True):
 
-        save_report_fg(self, file_name, file_path)
+        save_report_fg(self, file_name, file_path, add_settings)
 
 
     @copy_doc_func_to_method(save_fg)
@@ -543,6 +542,49 @@ class FOOOFGroup(FOOOF):
         print(gen_results_fg_str(self, concise))
 
 
+    def save_model_report(self, index, file_name, file_path=None, plt_log=False,
+                          add_settings=True, **plot_kwargs):
+        """"Save out an individual model report for a specified model fit.
+
+        Parameters
+        ----------
+        index : int
+            Index of the model fit to save out.
+        file_name : str
+            Name to give the saved out file.
+        file_path : str, optional
+            Path to directory to save to. If None, saves to current directory.
+        plt_log : bool, optional, default: False
+            Whether or not to plot the frequency axis in log space.
+        add_settings : bool, optional, default: True
+            Whether to add a print out of the model settings to the end of the report.
+        plot_kwargs : keyword arguments
+            Keyword arguments to pass into the plot method.
+        """
+
+        self.get_fooof(ind=index, regenerate=True).save_report(\
+            file_name, file_path, plt_log, **plot_kwargs)
+
+
+    def to_df(self, peak_org):
+        """Convert and extract the model results as a pandas object.
+
+        Parameters
+        ----------
+        peak_org : int or Bands
+            How to organize peaks.
+            If int, extracts the first n peaks.
+            If Bands, extracts peaks based on band definitions.
+
+        Returns
+        -------
+        pd.DataFrame
+            Model results organized into a pandas object.
+        """
+
+        return group_to_dataframe(self.get_results(), peak_org)
+
+
     def _fit(self, *args, **kwargs):
         """Create an alias to FOOOF.fit for FOOOFGroup object, for internal use."""
 
diff --git a/fooof/objs/utils.py b/fooof/objs/utils.py
index 4ef05d9..fe1b740 100644
--- a/fooof/objs/utils.py
+++ b/fooof/objs/utils.py
@@ -179,7 +179,7 @@ def combine_fooofs(fooofs):
         fg.power_spectra = temp_power_spectra
 
     # Set the check data mode, as True if any of the inputs have it on, False otherwise
-    fg.set_check_data_mode(any([getattr(f_obj, '_check_data') for f_obj in fooofs]))
+    fg.set_check_data_mode(any(getattr(f_obj, '_check_data') for f_obj in fooofs))
 
     # Add data information information
     fg.add_meta_data(fooofs[0].get_meta_data())
@@ -219,9 +219,14 @@ def fit_fooof_3d(fg, freqs, power_spectra, freq_range=None, n_jobs=1):
     >>> fgs = fit_fooof_3d(fg, freqs, power_spectra, freq_range=[3, 30])  # doctest:+SKIP
     """
 
-    fgs = []
-    for cond_spectra in power_spectra:
-        fg.fit(freqs, cond_spectra, freq_range, n_jobs)
-        fgs.append(fg.copy())
+    # Reshape 3d data to 2d and fit, in order to fit with a single group model object
+    shape = np.shape(power_spectra)
+    powers_2d = np.reshape(power_spectra, (shape[0] * shape[1], shape[2]))
+
+    fg.fit(freqs, powers_2d, freq_range, n_jobs)
+
+    # Reorganize 2d results into a list of model group objects, to reflect original shape
+    fgs = [fg.get_group(range(dim_a * shape[1], (dim_a + 1) * shape[1])) \
+        for dim_a in range(shape[0])]
 
     return fgs
diff --git a/fooof/plts/__init__.py b/fooof/plts/__init__.py
index 981ba12..95e05f4 100644
--- a/fooof/plts/__init__.py
+++ b/fooof/plts/__init__.py
@@ -1,3 +1,4 @@
 """Plots sub-module for FOOOF."""
 
-from .spectra import plot_spectrum, plot_spectra
+from .spectra import plot_spectra
+from .spectra import plot_spectra as plot_spectrum
diff --git a/fooof/plts/annotate.py b/fooof/plts/annotate.py
index 04faacf..d72559a 100644
--- a/fooof/plts/annotate.py
+++ b/fooof/plts/annotate.py
@@ -6,30 +6,31 @@ from fooof.core.utils import nearest_ind
 from fooof.core.errors import NoModelError
 from fooof.core.funcs import gaussian_function
 from fooof.core.modutils import safe_import, check_dependency
+
 from fooof.sim.gen import gen_aperiodic
-from fooof.plts.utils import check_ax
-from fooof.plts.spectra import plot_spectrum
-from fooof.plts.settings import PLT_FIGSIZES, PLT_COLORS
-from fooof.plts.style import check_n_style, style_spectrum_plot
 from fooof.analysis.periodic import get_band_peak_fm
 from fooof.utils.params import compute_knee_frequency, compute_fwhm
 
+from fooof.plts.spectra import plot_spectra
+from fooof.plts.utils import check_ax, savefig
+from fooof.plts.settings import PLT_FIGSIZES, PLT_COLORS
+from fooof.plts.style import style_spectrum_plot
+
 plt = safe_import('.pyplot', 'matplotlib')
 mpatches = safe_import('.patches', 'matplotlib')
 
 ###################################################################################################
 ###################################################################################################
 
+@savefig
 @check_dependency(plt, 'matplotlib')
-def plot_annotated_peak_search(fm, plot_style=style_spectrum_plot):
+def plot_annotated_peak_search(fm):
     """Plot a series of plots illustrating the peak search from a flattened spectrum.
 
     Parameters
     ----------
     fm : FOOOF
         FOOOF object, with model fit, data and settings available.
-    plot_style : callable, optional, default: style_spectrum_plot
-        A function to call to apply styling & aesthetics to the plots.
     """
 
     # Recalculate the initial aperiodic fit and flattened spectrum that
@@ -40,20 +41,21 @@ def plot_annotated_peak_search(fm, plot_style=style_spectrum_plot):
     # Calculate ylims of the plot that are scaled to the range of the data
     ylims = [min(flatspec) - 0.1 * np.abs(min(flatspec)), max(flatspec) + 0.1 * max(flatspec)]
 
+    # Sort parameters by peak height
+    gaussian_params = fm.gaussian_params_[fm.gaussian_params_[:, 1].argsort()][::-1]
+
     # Loop through the iterative search for each peak
     for ind in range(fm.n_peaks_ + 1):
 
         # This forces the creation of a new plotting axes per iteration
         ax = check_ax(None, PLT_FIGSIZES['spectral'])
 
-        plot_spectrum(fm.freqs, flatspec, ax=ax, plot_style=None,
-                      label='Flattened Spectrum', color=PLT_COLORS['data'], linewidth=2.5)
-        plot_spectrum(fm.freqs, [fm.peak_threshold * np.std(flatspec)]*len(fm.freqs),
-                      ax=ax, plot_style=None, label='Relative Threshold',
-                      color='orange', linewidth=2.5, linestyle='dashed')
-        plot_spectrum(fm.freqs, [fm.min_peak_height]*len(fm.freqs),
-                      ax=ax, plot_style=None, label='Absolute Threshold',
-                      color='red', linewidth=2.5, linestyle='dashed')
+        plot_spectra(fm.freqs, flatspec, ax=ax, linewidth=2.5,
+                     label='Flattened Spectrum', color=PLT_COLORS['data'])
+        plot_spectra(fm.freqs, [fm.peak_threshold * np.std(flatspec)]*len(fm.freqs), ax=ax,
+                     label='Relative Threshold', color='orange', linewidth=2.5, linestyle='dashed')
+        plot_spectra(fm.freqs, [fm.min_peak_height]*len(fm.freqs), ax=ax,
+                     label='Absolute Threshold', color='red', linewidth=2.5, linestyle='dashed')
 
         maxi = np.argmax(flatspec)
         ax.plot(fm.freqs[maxi], flatspec[maxi], '.',
@@ -64,19 +66,19 @@ def plot_annotated_peak_search(fm, plot_style=style_spectrum_plot):
 
         if ind < fm.n_peaks_:
 
-            gauss = gaussian_function(fm.freqs, *fm.gaussian_params_[ind, :])
-            plot_spectrum(fm.freqs, gauss, ax=ax, plot_style=None,
-                          label='Gaussian Fit', color=PLT_COLORS['periodic'],
-                          linestyle=':', linewidth=3.0)
+            gauss = gaussian_function(fm.freqs, *gaussian_params[ind, :])
+            plot_spectra(fm.freqs, gauss, ax=ax, label='Gaussian Fit',
+                         color=PLT_COLORS['periodic'], linestyle=':', linewidth=3.0)
 
             flatspec = flatspec - gauss
 
-        check_n_style(plot_style, ax, False, True)
+        style_spectrum_plot(ax, False, True)
 
 
+@savefig
 @check_dependency(plt, 'matplotlib')
-def plot_annotated_model(fm, plt_log=False, annotate_peaks=True, annotate_aperiodic=True,
-                         ax=None, plot_style=style_spectrum_plot):
+def plot_annotated_model(fm, plt_log=False, annotate_peaks=True,
+                         annotate_aperiodic=True, ax=None):
     """Plot a an annotated power spectrum and model, from a FOOOF object.
 
     Parameters
@@ -85,10 +87,12 @@ def plot_annotated_model(fm, plt_log=False, annotate_peaks=True, annotate_aperio
         FOOOF object, with model fit, data and settings available.
     plt_log : boolean, optional, default: False
         Whether to plot the frequency values in log10 spacing.
+    annotate_peaks : boolean, optional, default: True
+        Whether to annotate the periodic components of the model fit.
+    annotate_aperiodic : boolean, optional, default: True
+        Whether to annotate the aperiodic components of the model fit.
     ax : matplotlib.Axes, optional
         Figure axes upon which to plot.
-    plot_style : callable, optional, default: style_spectrum_plot
-        A function to call to apply styling & aesthetics to the plots.
 
     Raises
     ------
@@ -108,7 +112,7 @@ def plot_annotated_model(fm, plt_log=False, annotate_peaks=True, annotate_aperio
 
     # Create the baseline figure
     ax = check_ax(ax, PLT_FIGSIZES['spectral'])
-    fm.plot(plot_peaks='dot-shade-width', plt_log=plt_log, ax=ax, plot_style=None,
+    fm.plot(plot_peaks='dot-shade-width', plt_log=plt_log, ax=ax,
             data_kwargs={'lw' : lw1, 'alpha' : 0.6},
             aperiodic_kwargs={'lw' : lw1, 'zorder' : 10},
             model_kwargs={'lw' : lw1, 'alpha' : 0.5},
@@ -129,7 +133,7 @@ def plot_annotated_model(fm, plt_log=False, annotate_peaks=True, annotate_aperio
     #   See: https://github.com/matplotlib/matplotlib/issues/12820. Fixed in 3.2.1.
     bug_buff = 0.000001
 
-    if annotate_peaks:
+    if annotate_peaks and fm.n_peaks_:
 
         # Extract largest peak, to annotate, grabbing gaussian params
         gauss = get_band_peak_fm(fm, fm.freq_range, attribute='gaussian_params')
@@ -215,7 +219,7 @@ def plot_annotated_model(fm, plt_log=False, annotate_peaks=True, annotate_aperio
                     color=PLT_COLORS['aperiodic'], fontsize=fontsize)
 
     # Apply style to plot & tune grid styling
-    check_n_style(plot_style, ax, plt_log, True)
+    style_spectrum_plot(ax, plt_log, True)
     ax.grid(True, alpha=0.5)
 
     # Add labels to plot in the legend
diff --git a/fooof/plts/aperiodic.py b/fooof/plts/aperiodic.py
index fafc1dd..905b951 100644
--- a/fooof/plts/aperiodic.py
+++ b/fooof/plts/aperiodic.py
@@ -3,21 +3,23 @@
 from itertools import cycle
 
 import numpy as np
+import matplotlib.pyplot as plt
 
 from fooof.sim.gen import gen_freqs, gen_aperiodic
 from fooof.core.modutils import safe_import, check_dependency
 from fooof.plts.settings import PLT_FIGSIZES
-from fooof.plts.style import check_n_style, style_param_plot
-from fooof.plts.utils import check_ax, recursive_plot, check_plot_kwargs
+from fooof.plts.style import style_param_plot, style_plot
+from fooof.plts.utils import check_ax, recursive_plot, savefig, check_plot_kwargs
 
 plt = safe_import('.pyplot', 'matplotlib')
 
 ###################################################################################################
 ###################################################################################################
 
+@savefig
+@style_plot
 @check_dependency(plt, 'matplotlib')
-def plot_aperiodic_params(aps, colors=None, labels=None,
-                          ax=None, plot_style=style_param_plot, **plot_kwargs):
+def plot_aperiodic_params(aps, colors=None, labels=None, ax=None, **plot_kwargs):
     """Plot aperiodic parameters as dots representing offset and exponent value.
 
     Parameters
@@ -30,17 +32,14 @@ def plot_aperiodic_params(aps, colors=None, labels=None,
         Label(s) for plotted data, to be added in a legend.
     ax : matplotlib.Axes, optional
         Figure axes upon which to plot.
-    plot_style : callable, optional, default: style_param_plot
-        A function to call to apply styling & aesthetics to the plot.
     **plot_kwargs
-        Keyword arguments to pass into the plot call.
+        Keyword arguments to pass into the ``style_plot``.
     """
 
     ax = check_ax(ax, plot_kwargs.pop('figsize', PLT_FIGSIZES['params']))
 
     if isinstance(aps, list):
-        recursive_plot(aps, plot_aperiodic_params, ax, colors=colors, labels=labels,
-                       plot_style=plot_style, **plot_kwargs)
+        recursive_plot(aps, plot_aperiodic_params, ax, colors=colors, labels=labels)
 
     else:
 
@@ -48,6 +47,7 @@ def plot_aperiodic_params(aps, colors=None, labels=None,
         xs, ys = aps[:, 0], aps[:, -1]
         sizes = plot_kwargs.pop('s', 150)
 
+        # Create the plot
         plot_kwargs = check_plot_kwargs(plot_kwargs, {'alpha' : 0.7})
         ax.scatter(xs, ys, sizes, c=colors, label=labels, **plot_kwargs)
 
@@ -55,13 +55,15 @@ def plot_aperiodic_params(aps, colors=None, labels=None,
     ax.set_xlabel('Offset')
     ax.set_ylabel('Exponent')
 
-    check_n_style(plot_style, ax)
+    style_param_plot(ax)
 
 
+@savefig
+@style_plot
 @check_dependency(plt, 'matplotlib')
 def plot_aperiodic_fits(aps, freq_range, control_offset=False,
                         log_freqs=False, colors=None, labels=None,
-                        ax=None, plot_style=style_param_plot, **plot_kwargs):
+                        ax=None, **plot_kwargs):
     """Plot reconstructions of model aperiodic fits.
 
     Parameters
@@ -80,10 +82,8 @@ def plot_aperiodic_fits(aps, freq_range, control_offset=False,
         Label(s) for plotted data, to be added in a legend.
     ax : matplotlib.Axes, optional
         Figure axes upon which to plot.
-    plot_style : callable, optional, default: style_param_plot
-        A function to call to apply styling & aesthetics to the plot.
     **plot_kwargs
-        Keyword arguments to pass into the plot call.
+        Keyword arguments to pass into the ``style_plot``.
     """
 
     ax = check_ax(ax, plot_kwargs.pop('figsize', PLT_FIGSIZES['params']))
@@ -93,11 +93,9 @@ def plot_aperiodic_fits(aps, freq_range, control_offset=False,
         if not colors:
             colors = cycle(plt.rcParams['axes.prop_cycle'].by_key()['color'])
 
-        recursive_plot(aps, plot_function=plot_aperiodic_fits, ax=ax,
-                       freq_range=tuple(freq_range),
-                       control_offset=control_offset,
-                       log_freqs=log_freqs, colors=colors, labels=labels,
-                       plot_style=plot_style, **plot_kwargs)
+        recursive_plot(aps, plot_aperiodic_fits, ax=ax, freq_range=tuple(freq_range),
+                       control_offset=control_offset, log_freqs=log_freqs, colors=colors,
+                       labels=labels, **plot_kwargs)
     else:
 
         freqs = gen_freqs(freq_range, 0.1)
@@ -118,8 +116,7 @@ def plot_aperiodic_fits(aps, freq_range, control_offset=False,
             # Recreate & plot the aperiodic component from parameters
             ap_vals = gen_aperiodic(freqs, ap_params)
 
-            plot_kwargs = check_plot_kwargs(plot_kwargs, {'alpha' : 0.35, 'linewidth' : 1.25})
-            ax.plot(plt_freqs, ap_vals, color=colors, **plot_kwargs)
+            ax.plot(plt_freqs, ap_vals, color=colors, alpha=0.35, linewidth=1.25)
 
             # Collect a running average across components
             avg_vals = np.nansum(np.vstack([avg_vals, ap_vals]), axis=0)
@@ -127,8 +124,7 @@ def plot_aperiodic_fits(aps, freq_range, control_offset=False,
         # Plot the average component
         avg = avg_vals / aps.shape[0]
         avg_color = 'black' if not colors else colors
-        ax.plot(plt_freqs, avg, linewidth=plot_kwargs.get('linewidth')*3,
-                color=avg_color, label=labels)
+        ax.plot(plt_freqs, avg, linewidth=3.75, color=avg_color, label=labels)
 
     # Add axis labels
     ax.set_xlabel('log(Frequency)' if log_freqs else 'Frequency')
@@ -137,5 +133,4 @@ def plot_aperiodic_fits(aps, freq_range, control_offset=False,
     # Set plot limit
     ax.set_xlim(np.log10(freq_range) if log_freqs else freq_range)
 
-    # Apply plot style
-    check_n_style(plot_style, ax)
+    style_param_plot(ax)
diff --git a/fooof/plts/error.py b/fooof/plts/error.py
index c870900..af04840 100644
--- a/fooof/plts/error.py
+++ b/fooof/plts/error.py
@@ -3,19 +3,20 @@
 import numpy as np
 
 from fooof.core.modutils import safe_import, check_dependency
-from fooof.plts.spectra import plot_spectrum
+from fooof.plts.spectra import plot_spectra
 from fooof.plts.settings import PLT_FIGSIZES
-from fooof.plts.style import check_n_style, style_spectrum_plot
-from fooof.plts.utils import check_ax
+from fooof.plts.style import style_spectrum_plot, style_plot
+from fooof.plts.utils import check_ax, savefig
 
 plt = safe_import('.pyplot', 'matplotlib')
 
 ###################################################################################################
 ###################################################################################################
 
+@savefig
+@style_plot
 @check_dependency(plt, 'matplotlib')
-def plot_spectral_error(freqs, error, shade=None, log_freqs=False,
-                        ax=None, plot_style=style_spectrum_plot, **plot_kwargs):
+def plot_spectral_error(freqs, error, shade=None, log_freqs=False, ax=None, **plot_kwargs):
     """Plot frequency by frequency error values.
 
     Parameters
@@ -31,17 +32,15 @@ def plot_spectral_error(freqs, error, shade=None, log_freqs=False,
         Whether to plot the frequency axis in log spacing.
     ax : matplotlib.Axes, optional
         Figure axes upon which to plot.
-    plot_style : callable, optional, default: style_spectrum_plot
-        A function to call to apply styling & aesthetics to the plot.
     **plot_kwargs
-        Keyword arguments to be passed to `plot_spectra` or to the plot call.
+        Keyword arguments to pass into the ``style_plot``.
     """
 
     ax = check_ax(ax, plot_kwargs.pop('figsize', PLT_FIGSIZES['spectral']))
 
     plt_freqs = np.log10(freqs) if log_freqs else freqs
 
-    plot_spectrum(plt_freqs, error, plot_style=None, ax=ax, linewidth=3, **plot_kwargs)
+    plot_spectra(plt_freqs, error, ax=ax, linewidth=3)
 
     if np.any(shade):
         ax.fill_between(plt_freqs, error-shade, error+shade, alpha=0.25)
@@ -51,5 +50,5 @@ def plot_spectral_error(freqs, error, shade=None, log_freqs=False,
         ax.set_ylim([0, ymax])
     ax.set_xlim(plt_freqs.min(), plt_freqs.max())
 
-    check_n_style(plot_style, ax, log_freqs, True)
+    style_spectrum_plot(ax, log_freqs, True)
     ax.set_ylabel('Absolute Error')
diff --git a/fooof/plts/fg.py b/fooof/plts/fg.py
index f4d1214..093eaae 100644
--- a/fooof/plts/fg.py
+++ b/fooof/plts/fg.py
@@ -5,11 +5,12 @@ Notes
 This file contains plotting functions that take as input a FOOOFGroup object.
 """
 
-from fooof.core.io import fname, fpath
 from fooof.core.errors import NoModelError
 from fooof.core.modutils import safe_import, check_dependency
 from fooof.plts.settings import PLT_FIGSIZES
 from fooof.plts.templates import plot_scatter_1, plot_scatter_2, plot_hist
+from fooof.plts.utils import savefig
+from fooof.plts.style import style_plot
 
 plt = safe_import('.pyplot', 'matplotlib')
 gridspec = safe_import('.gridspec', 'matplotlib')
@@ -17,8 +18,9 @@ gridspec = safe_import('.gridspec', 'matplotlib')
 ###################################################################################################
 ###################################################################################################
 
+@savefig
 @check_dependency(plt, 'matplotlib')
-def plot_fg(fg, save_fig=False, file_name=None, file_path=None):
+def plot_fg(fg, save_fig=False, file_name=None, file_path=None, **plot_kwargs):
     """Plot a figure with subplots visualizing the parameters from a FOOOFGroup object.
 
     Parameters
@@ -41,29 +43,30 @@ def plot_fg(fg, save_fig=False, file_name=None, file_path=None):
     if not fg.has_model:
         raise NoModelError("No model fit results are available, can not proceed.")
 
-    fig = plt.figure(figsize=PLT_FIGSIZES['group'])
+    fig = plt.figure(figsize=plot_kwargs.pop('figsize', PLT_FIGSIZES['group']))
     gs = gridspec.GridSpec(2, 2, wspace=0.4, hspace=0.25, height_ratios=[1, 1.2])
 
+    # Apply scatter kwargs to all subplots
+    scatter_kwargs = plot_kwargs
+    scatter_kwargs['all_axes'] = True
+
     # Aperiodic parameters plot
     ax0 = plt.subplot(gs[0, 0])
-    plot_fg_ap(fg, ax0)
+    plot_fg_ap(fg, ax0, **scatter_kwargs)
 
     # Goodness of fit plot
     ax1 = plt.subplot(gs[0, 1])
-    plot_fg_gf(fg, ax1)
+    plot_fg_gf(fg, ax1, **scatter_kwargs)
 
     # Center frequencies plot
     ax2 = plt.subplot(gs[1, :])
-    plot_fg_peak_cens(fg, ax2)
-
-    if save_fig:
-        if not file_name:
-            raise ValueError("Input 'file_name' is required to save out the plot.")
-        plt.savefig(fpath(file_path, fname(file_name, 'png')))
+    plot_fg_peak_cens(fg, ax2, **plot_kwargs)
 
 
+@savefig
+@style_plot
 @check_dependency(plt, 'matplotlib')
-def plot_fg_ap(fg, ax=None):
+def plot_fg_ap(fg, ax=None, **plot_kwargs):
     """Plot aperiodic fit parameters, in a scatter plot.
 
     Parameters
@@ -72,19 +75,27 @@ def plot_fg_ap(fg, ax=None):
         Object to plot data from.
     ax : matplotlib.Axes, optional
         Figure axes upon which to plot.
+    **plot_kwargs
+        Keyword arguments to pass into the ``style_plot``.
     """
 
     if fg.aperiodic_mode == 'knee':
-        plot_scatter_2(fg.get_params('aperiodic_params', 'exponent'), 'Knee',
-                       fg.get_params('aperiodic_params', 'knee'), 'Exponent',
+        plot_scatter_2(fg.get_params('aperiodic_params', 'exponent'), 'Exponent',
+                       fg.get_params('aperiodic_params', 'knee'), 'Knee',
+                       'Aperiodic Fit', ax=ax)
+    elif fg.aperiodic_mode == 'lorentzian':
+        plot_scatter_2(fg.get_params('aperiodic_params', 'exponent'), 'Exponent',
+                       fg.get_params('aperiodic_params', 'log knee'), 'Log Knee',
                        'Aperiodic Fit', ax=ax)
     else:
         plot_scatter_1(fg.get_params('aperiodic_params', 'exponent'), 'Exponent',
                        'Aperiodic Fit', ax=ax)
 
 
+@savefig
+@style_plot
 @check_dependency(plt, 'matplotlib')
-def plot_fg_gf(fg, ax=None):
+def plot_fg_gf(fg, ax=None, **plot_kwargs):
     """Plot goodness of fit results, in a scatter plot.
 
     Parameters
@@ -93,14 +104,18 @@ def plot_fg_gf(fg, ax=None):
         Object to plot data from.
     ax : matplotlib.Axes, optional
         Figure axes upon which to plot.
+    **plot_kwargs
+        Keyword arguments to pass into the ``style_plot``.
     """
 
     plot_scatter_2(fg.get_params('error'), 'Error',
                    fg.get_params('r_squared'), 'R^2', 'Goodness of Fit', ax=ax)
 
 
+@savefig
+@style_plot
 @check_dependency(plt, 'matplotlib')
-def plot_fg_peak_cens(fg, ax=None):
+def plot_fg_peak_cens(fg, ax=None, **plot_kwargs):
     """Plot peak center frequencies, in a histogram.
 
     Parameters
@@ -109,6 +124,8 @@ def plot_fg_peak_cens(fg, ax=None):
         Object to plot data from.
     ax : matplotlib.Axes, optional
         Figure axes upon which to plot.
+    **plot_kwargs
+        Keyword arguments to pass into the ``style_plot``.
     """
 
     plot_hist(fg.get_params('peak_params', 0)[:, 0], 'Center Frequency',
diff --git a/fooof/plts/fm.py b/fooof/plts/fm.py
index 68be6ea..0cbd168 100644
--- a/fooof/plts/fm.py
+++ b/fooof/plts/fm.py
@@ -7,27 +7,27 @@ This file contains plotting functions that take as input a FOOOF object.
 
 import numpy as np
 
-from fooof.core.io import fname, fpath
 from fooof.core.utils import nearest_ind
 from fooof.core.modutils import safe_import, check_dependency
 from fooof.sim.gen import gen_periodic
 from fooof.utils.data import trim_spectrum
 from fooof.utils.params import compute_fwhm
-from fooof.plts.spectra import plot_spectrum
+from fooof.plts.spectra import plot_spectra
 from fooof.plts.settings import PLT_FIGSIZES, PLT_COLORS
-from fooof.plts.utils import check_ax, check_plot_kwargs
-from fooof.plts.style import check_n_style, style_spectrum_plot
+from fooof.plts.utils import check_ax, check_plot_kwargs, savefig
+from fooof.plts.style import style_spectrum_plot, style_plot
 
 plt = safe_import('.pyplot', 'matplotlib')
 
 ###################################################################################################
 ###################################################################################################
 
+@savefig
+@style_plot
 @check_dependency(plt, 'matplotlib')
 def plot_fm(fm, plot_peaks=None, plot_aperiodic=True, plt_log=False, add_legend=True,
-            save_fig=False, file_name=None, file_path=None,
-            ax=None, plot_style=style_spectrum_plot,
-            data_kwargs=None, model_kwargs=None, aperiodic_kwargs=None, peak_kwargs=None):
+            save_fig=False, file_name=None, file_path=None, ax=None, data_kwargs=None,
+            model_kwargs=None, aperiodic_kwargs=None, peak_kwargs=None, **plot_kwargs):
     """Plot the power spectrum and model fit results from a FOOOF object.
 
     Parameters
@@ -51,10 +51,10 @@ def plot_fm(fm, plot_peaks=None, plot_aperiodic=True, plt_log=False, add_legend=
         Path to directory to save to. If None, saves to current directory.
     ax : matplotlib.Axes, optional
         Figure axes upon which to plot.
-    plot_style : callable, optional, default: style_spectrum_plot
-        A function to call to apply styling & aesthetics to the plot.
     data_kwargs, model_kwargs, aperiodic_kwargs, peak_kwargs : None or dict, optional
         Keyword arguments to pass into the plot call for each plot element.
+    **plot_kwargs
+        Keyword arguments to pass into the ``style_plot``.
 
     Notes
     -----
@@ -62,7 +62,7 @@ def plot_fm(fm, plot_peaks=None, plot_aperiodic=True, plt_log=False, add_legend=
     the y-axis (power) is plotted in log spacing by default.
     """
 
-    ax = check_ax(ax, PLT_FIGSIZES['spectral'])
+    ax = check_ax(ax, plot_kwargs.pop('figsize', PLT_FIGSIZES['spectral']))
 
     # Log settings - note that power values in FOOOF objects are already logged
     log_freqs = plt_log
@@ -70,40 +70,32 @@ def plot_fm(fm, plot_peaks=None, plot_aperiodic=True, plt_log=False, add_legend=
 
     # Plot the data, if available
     if fm.has_data:
-        data_kwargs = check_plot_kwargs(data_kwargs, \
-            {'color' : PLT_COLORS['data'], 'linewidth' : 2.0,
-             'label' : 'Original Spectrum' if add_legend else None})
-        plot_spectrum(fm.freqs, fm.power_spectrum, log_freqs, log_powers,
-                      ax=ax, plot_style=None, **data_kwargs)
+        data_defaults = {'color' : PLT_COLORS['data'], 'linewidth' : 2.0,
+                         'label' : 'Original Spectrum' if add_legend else None}
+        data_kwargs = check_plot_kwargs(data_kwargs, data_defaults)
+        plot_spectra(fm.freqs, fm.power_spectrum, log_freqs, log_powers, ax=ax, **data_kwargs)
 
     # Add the full model fit, and components (if requested)
     if fm.has_model:
-        model_kwargs = check_plot_kwargs(model_kwargs, \
-            {'color' : PLT_COLORS['model'], 'linewidth' : 3.0, 'alpha' : 0.5,
-             'label' : 'Full Model Fit' if add_legend else None})
-        plot_spectrum(fm.freqs, fm.fooofed_spectrum_, log_freqs, log_powers,
-                      ax=ax, plot_style=None, **model_kwargs)
+        model_defaults = {'color' : PLT_COLORS['model'], 'linewidth' : 3.0, 'alpha' : 0.5,
+                          'label' : 'Full Model Fit' if add_legend else None}
+        model_kwargs = check_plot_kwargs(model_kwargs, model_defaults)
+        plot_spectra(fm.freqs, fm.fooofed_spectrum_, log_freqs, log_powers, ax=ax, **model_kwargs)
 
         # Plot the aperiodic component of the model fit
         if plot_aperiodic:
-            aperiodic_kwargs = check_plot_kwargs(aperiodic_kwargs, \
-                {'color' : PLT_COLORS['aperiodic'], 'linewidth' : 3.0, 'alpha' : 0.5,
-                 'linestyle' : 'dashed', 'label' : 'Aperiodic Fit' if add_legend else None})
-            plot_spectrum(fm.freqs, fm._ap_fit, log_freqs, log_powers,
-                          ax=ax, plot_style=None, **aperiodic_kwargs)
+            aperiodic_defaults = {'color' : PLT_COLORS['aperiodic'], 'linewidth' : 3.0,
+                                  'alpha' : 0.5, 'linestyle' : 'dashed',
+                                  'label' : 'Aperiodic Fit' if add_legend else None}
+            aperiodic_kwargs = check_plot_kwargs(aperiodic_kwargs, aperiodic_defaults)
+            plot_spectra(fm.freqs, fm._ap_fit, log_freqs, log_powers, ax=ax, **aperiodic_kwargs)
 
         # Plot the periodic components of the model fit
         if plot_peaks:
-            _add_peaks(fm, plot_peaks, plt_log, ax=ax, peak_kwargs=peak_kwargs)
-
-    # Apply style to plot
-    check_n_style(plot_style, ax, log_freqs, True)
+            _add_peaks(fm, plot_peaks, plt_log, ax, peak_kwargs)
 
-    # Save out figure, if requested
-    if save_fig:
-        if not file_name:
-            raise ValueError("Input 'file_name' is required to save out the plot.")
-        plt.savefig(fpath(file_path, fname(file_name, 'png')))
+    # Apply default style to plot
+    style_spectrum_plot(ax, log_freqs, True)
 
 
 def _add_peaks(fm, approach, plt_log, ax, peak_kwargs):
@@ -162,18 +154,18 @@ def _add_peaks_shade(fm, plt_log, ax, **plot_kwargs):
     ax : matplotlib.Axes
         Figure axes upon which to plot.
     **plot_kwargs
-        Keyword arguments to pass into the plot call.
+        Keyword arguments to pass into the ``fill_between``.
     """
 
-    kwargs = check_plot_kwargs(plot_kwargs,
-                               {'color' : PLT_COLORS['periodic'], 'alpha' : 0.25})
+    defaults = {'color' : PLT_COLORS['periodic'], 'alpha' : 0.25}
+    plot_kwargs = check_plot_kwargs(plot_kwargs, defaults)
 
-    for peak in fm.get_params('gaussian_params'):
+    for peak in fm.gaussian_params_:
 
         peak_freqs = np.log10(fm.freqs) if plt_log else fm.freqs
         peak_line = fm._ap_fit + gen_periodic(fm.freqs, peak)
 
-        ax.fill_between(peak_freqs, peak_line, fm._ap_fit, **kwargs)
+        ax.fill_between(peak_freqs, peak_line, fm._ap_fit, **plot_kwargs)
 
 
 def _add_peaks_dot(fm, plt_log, ax, **plot_kwargs):
@@ -191,20 +183,19 @@ def _add_peaks_dot(fm, plt_log, ax, **plot_kwargs):
         Keyword arguments to pass into the plot call.
     """
 
-    kwargs = check_plot_kwargs(plot_kwargs,
-                               {'color' : PLT_COLORS['periodic'],
-                                'alpha' : 0.6, 'lw' : 2.5, 'ms' : 6})
+    defaults = {'color' : PLT_COLORS['periodic'], 'alpha' : 0.6, 'lw' : 2.5, 'ms' : 6}
+    plot_kwargs = check_plot_kwargs(plot_kwargs, defaults)
 
-    for peak in fm.get_params('peak_params'):
+    for peak in fm.peak_params_:
 
         ap_point = np.interp(peak[0], fm.freqs, fm._ap_fit)
         freq_point = np.log10(peak[0]) if plt_log else peak[0]
 
         # Add the line from the aperiodic fit up the tip of the peak
-        ax.plot([freq_point, freq_point], [ap_point, ap_point + peak[1]], **kwargs)
+        ax.plot([freq_point, freq_point], [ap_point, ap_point + peak[1]], **plot_kwargs)
 
         # Add an extra dot at the tip of the peak
-        ax.plot(freq_point, ap_point + peak[1], marker='o', **kwargs)
+        ax.plot(freq_point, ap_point + peak[1], marker='o', **plot_kwargs)
 
 
 def _add_peaks_outline(fm, plt_log, ax, **plot_kwargs):
@@ -222,11 +213,10 @@ def _add_peaks_outline(fm, plt_log, ax, **plot_kwargs):
         Keyword arguments to pass into the plot call.
     """
 
-    kwargs = check_plot_kwargs(plot_kwargs,
-                               {'color' : PLT_COLORS['periodic'],
-                                'alpha' : 0.7, 'lw' : 1.5})
+    defaults = {'color' : PLT_COLORS['periodic'], 'alpha' : 0.7, 'lw' : 1.5}
+    plot_kwargs = check_plot_kwargs(plot_kwargs, defaults)
 
-    for peak in fm.get_params('gaussian_params'):
+    for peak in fm.gaussian_params_:
 
         # Define the frequency range around each peak to plot - peak bandwidth +/- 3
         peak_range = [peak[0] - peak[2]*3, peak[0] + peak[2]*3]
@@ -237,7 +227,7 @@ def _add_peaks_outline(fm, plt_log, ax, **plot_kwargs):
 
         # Plot the peak outline
         peak_freqs = np.log10(peak_freqs) if plt_log else peak_freqs
-        ax.plot(peak_freqs, peak_line, **kwargs)
+        ax.plot(peak_freqs, peak_line, **plot_kwargs)
 
 
 def _add_peaks_line(fm, plt_log, ax, **plot_kwargs):
@@ -255,16 +245,16 @@ def _add_peaks_line(fm, plt_log, ax, **plot_kwargs):
         Keyword arguments to pass into the plot call.
     """
 
-    kwargs = check_plot_kwargs(plot_kwargs,
-                               {'color' : PLT_COLORS['periodic'],
-                                'alpha' : 0.7, 'lw' : 1.4, 'ms' : 10})
+    defaults = {'color' : PLT_COLORS['periodic'], 'alpha' : 0.7, 'lw' : 1.4, 'ms' : 10}
+    plot_kwargs = check_plot_kwargs(plot_kwargs, defaults)
 
     ylims = ax.get_ylim()
-    for peak in fm.get_params('peak_params'):
+
+    for peak in fm.peak_params_:
 
         freq_point = np.log10(peak[0]) if plt_log else peak[0]
-        ax.plot([freq_point, freq_point], ylims, '-', **kwargs)
-        ax.plot(freq_point, ylims[1], 'v', **kwargs)
+        ax.plot([freq_point, freq_point], ylims, '-', **plot_kwargs)
+        ax.plot(freq_point, ylims[1], 'v', **plot_kwargs)
 
 
 def _add_peaks_width(fm, plt_log, ax, **plot_kwargs):
@@ -287,9 +277,8 @@ def _add_peaks_width(fm, plt_log, ax, **plot_kwargs):
     the peak, though what is literally plotted is the full-width half-max.
     """
 
-    kwargs = check_plot_kwargs(plot_kwargs,
-                               {'color' : PLT_COLORS['periodic'],
-                                'alpha' : 0.6, 'lw' : 2.5, 'ms' : 6})
+    defaults = {'color' : PLT_COLORS['periodic'], 'alpha' : 0.6, 'lw' : 2.5, 'ms' : 6}
+    plot_kwargs = check_plot_kwargs(plot_kwargs, defaults)
 
     for peak in fm.gaussian_params_:
 
@@ -300,7 +289,7 @@ def _add_peaks_width(fm, plt_log, ax, **plot_kwargs):
         if plt_log:
             bw_freqs = np.log10(bw_freqs)
 
-        ax.plot(bw_freqs, [peak_top-(0.5*peak[1]), peak_top-(0.5*peak[1])], **kwargs)
+        ax.plot(bw_freqs, [peak_top-(0.5*peak[1]), peak_top-(0.5*peak[1])], **plot_kwargs)
 
 
 # Collect all the possible `add_peak_*` functions together
diff --git a/fooof/plts/periodic.py b/fooof/plts/periodic.py
index e654bfa..17e66f1 100644
--- a/fooof/plts/periodic.py
+++ b/fooof/plts/periodic.py
@@ -8,17 +8,18 @@ from fooof.sim import gen_freqs
 from fooof.core.funcs import gaussian_function
 from fooof.core.modutils import safe_import, check_dependency
 from fooof.plts.settings import PLT_FIGSIZES
-from fooof.plts.style import check_n_style, style_param_plot
-from fooof.plts.utils import check_ax, recursive_plot, check_plot_kwargs
+from fooof.plts.style import style_param_plot, style_plot
+from fooof.plts.utils import check_ax, recursive_plot, savefig, check_plot_kwargs
 
 plt = safe_import('.pyplot', 'matplotlib')
 
 ###################################################################################################
 ###################################################################################################
 
+@savefig
+@style_plot
 @check_dependency(plt, 'matplotlib')
-def plot_peak_params(peaks, freq_range=None, colors=None, labels=None,
-                     ax=None, plot_style=style_param_plot, **plot_kwargs):
+def plot_peak_params(peaks, freq_range=None, colors=None, labels=None, ax=None, **plot_kwargs):
     """Plot peak parameters as dots representing center frequency, power and bandwidth.
 
     Parameters
@@ -33,18 +34,15 @@ def plot_peak_params(peaks, freq_range=None, colors=None, labels=None,
         Label(s) for plotted data, to be added in a legend.
     ax : matplotlib.Axes, optional
         Figure axes upon which to plot.
-    plot_style : callable, optional, default: style_param_plot
-        A function to call to apply styling & aesthetics to the plot.
     **plot_kwargs
-        Keyword arguments to pass into the plot call.
+        Keyword arguments to pass into the ``style_plot``.
     """
 
     ax = check_ax(ax, plot_kwargs.pop('figsize', PLT_FIGSIZES['params']))
 
     # If there is a list, use recurse function to loop across arrays of data and plot them
     if isinstance(peaks, list):
-        recursive_plot(peaks, plot_peak_params, ax, colors=colors, labels=labels,
-                       plot_style=plot_style, **plot_kwargs)
+        recursive_plot(peaks, plot_peak_params, ax, colors=colors, labels=labels)
 
     # Otherwise, plot the array of data
     else:
@@ -66,11 +64,12 @@ def plot_peak_params(peaks, freq_range=None, colors=None, labels=None,
         ax.set_xlim(freq_range)
     ax.set_ylim([0, ax.get_ylim()[1]])
 
-    check_n_style(plot_style, ax)
+    style_param_plot(ax)
 
 
-def plot_peak_fits(peaks, freq_range=None, colors=None, labels=None,
-                   ax=None, plot_style=style_param_plot, **plot_kwargs):
+@savefig
+@style_plot
+def plot_peak_fits(peaks, freq_range=None, colors=None, labels=None, ax=None, **plot_kwargs):
     """Plot reconstructions of model peak fits.
 
     Parameters
@@ -86,8 +85,6 @@ def plot_peak_fits(peaks, freq_range=None, colors=None, labels=None,
         Label(s) for plotted data, to be added in a legend.
     ax : matplotlib.Axes, optional
         Figure axes upon which to plot.
-    plot_style : callable, optional, default: style_param_plot
-        A function to call to apply styling & aesthetics to the plot.
     **plot_kwargs
         Keyword arguments to pass into the plot call.
     """
@@ -101,8 +98,7 @@ def plot_peak_fits(peaks, freq_range=None, colors=None, labels=None,
 
         recursive_plot(peaks, plot_function=plot_peak_fits, ax=ax,
                        freq_range=tuple(freq_range) if freq_range else freq_range,
-                       colors=colors, labels=labels,
-                       plot_style=plot_style, **plot_kwargs)
+                       colors=colors, labels=labels, **plot_kwargs)
 
     else:
 
@@ -128,8 +124,7 @@ def plot_peak_fits(peaks, freq_range=None, colors=None, labels=None,
 
             # Create & plot the peak model from parameters
             peak_vals = gaussian_function(freqs, *peak_params)
-            plot_kwargs = check_plot_kwargs(plot_kwargs, {'alpha' : 0.35, 'linewidth' : 1.25})
-            ax.plot(freqs, peak_vals, color=colors, **plot_kwargs)
+            ax.plot(freqs, peak_vals, color=colors, alpha=0.35, linewidth=1.25)
 
             # Collect a running average average peaks
             avg_vals = np.nansum(np.vstack([avg_vals, peak_vals]), axis=0)
@@ -137,7 +132,7 @@ def plot_peak_fits(peaks, freq_range=None, colors=None, labels=None,
         # Plot the average across all components
         avg = avg_vals / peaks.shape[0]
         avg_color = 'black' if not colors else colors
-        ax.plot(freqs, avg, color=avg_color, linewidth=plot_kwargs.get('linewidth')*3, label=labels)
+        ax.plot(freqs, avg, color=avg_color, linewidth=3.75, label=labels)
 
     # Add axis labels
     ax.set_xlabel('Frequency')
@@ -148,4 +143,4 @@ def plot_peak_fits(peaks, freq_range=None, colors=None, labels=None,
     ax.set_ylim([0, ax.get_ylim()[1]])
 
     # Apply plot style
-    check_n_style(plot_style, ax)
+    style_param_plot(ax)
diff --git a/fooof/plts/settings.py b/fooof/plts/settings.py
index 94d5250..4b7f105 100644
--- a/fooof/plts/settings.py
+++ b/fooof/plts/settings.py
@@ -26,3 +26,27 @@ PLT_ALPHA_LEVELS = OrderedDict({0 : 0.50,
 PLT_ALIASES = {'linewidth' : ['lw', 'linewidth'],
                'markersize' : ['ms', 'markersize'],
                'linestyle' : ['ls', 'linestyle']}
+
+# Plot style arguments are those that can be defined on an axis object
+AXIS_STYLE_ARGS = ['title', 'xlabel', 'ylabel', 'xlim', 'ylim']
+
+# Line style arguments are those that can be defined on a line object
+LINE_STYLE_ARGS = ['alpha', 'lw', 'linewidth', 'ls', 'linestyle',
+                   'marker', 'ms', 'markersize']
+
+# Collection style arguments are those that can be defined on a collections object
+COLLECTION_STYLE_ARGS = ['alpha', 'edgecolor']
+
+# Custom style arguments are those that are custom-handled by the plot style function
+CUSTOM_STYLE_ARGS = ['title_fontsize', 'label_size', 'tick_labelsize',
+                     'legend_size', 'legend_loc']
+STYLERS = ['axis_styler', 'line_styler', 'custom_styler']
+STYLE_ARGS = AXIS_STYLE_ARGS + LINE_STYLE_ARGS + CUSTOM_STYLE_ARGS + STYLERS
+
+## Define default values for plot aesthetics
+# These are all custom style arguments
+TITLE_FONTSIZE = 20
+LABEL_SIZE = 16
+TICK_LABELSIZE = 16
+LEGEND_SIZE = 12
+LEGEND_LOC = 'best'
diff --git a/fooof/plts/spectra.py b/fooof/plts/spectra.py
index eaeafdb..c68acc6 100644
--- a/fooof/plts/spectra.py
+++ b/fooof/plts/spectra.py
@@ -5,104 +5,89 @@ Notes
 This file contains functions for plotting power spectra, that take in data directly.
 """
 
-from itertools import repeat
+from inspect import isfunction
+from itertools import repeat, cycle
 
 import numpy as np
+from scipy.stats import sem
 
 from fooof.core.modutils import safe_import, check_dependency
 from fooof.plts.settings import PLT_FIGSIZES
-from fooof.plts.style import check_n_style, style_spectrum_plot
-from fooof.plts.utils import check_ax, add_shades, check_plot_kwargs
+from fooof.plts.style import style_spectrum_plot, style_plot
+from fooof.plts.utils import check_ax, add_shades, savefig, check_plot_kwargs
 
 plt = safe_import('.pyplot', 'matplotlib')
 
 ###################################################################################################
 ###################################################################################################
 
+@savefig
+@style_plot
 @check_dependency(plt, 'matplotlib')
-def plot_spectrum(freqs, power_spectrum, log_freqs=False, log_powers=False,
-                  ax=None, plot_style=style_spectrum_plot, **plot_kwargs):
-    """Plot a power spectrum.
+def plot_spectra(freqs, power_spectra, log_freqs=False, log_powers=False,
+                 colors=None, labels=None, ax=None, **plot_kwargs):
+    """Plot one or multiple power spectra.
 
     Parameters
     ----------
-    freqs : 1d array
+    freqs : 1d or 2d array or list of 1d array
         Frequency values, to be plotted on the x-axis.
-    power_spectrum : 1d array
+    power_spectra : 1d or 2d array or list of 1d array
         Power values, to be plotted on the y-axis.
     log_freqs : bool, optional, default: False
         Whether to plot the frequency axis in log spacing.
     log_powers : bool, optional, default: False
         Whether to plot the power axis in log spacing.
+    colors : list of str, optional, default: None
+        Line colors of the spectra.
+    labels : list of str, optional, default: None
+        Legend labels for the spectra.
     ax : matplotlib.Axes, optional
-        Figure axis upon which to plot.
-    plot_style : callable, optional, default: style_spectrum_plot
-        A function to call to apply styling & aesthetics to the plot.
+        Figure axes upon which to plot.
     **plot_kwargs
-        Keyword arguments to be passed to the plot call.
+        Keyword arguments to pass into the ``style_plot``.
     """
 
     ax = check_ax(ax, plot_kwargs.pop('figsize', PLT_FIGSIZES['spectral']))
 
-    # Set plot data & labels, logging if requested
-    plt_freqs = np.log10(freqs) if log_freqs else freqs
-    plt_powers = np.log10(power_spectrum) if log_powers else power_spectrum
-
     # Create the plot
     plot_kwargs = check_plot_kwargs(plot_kwargs, {'linewidth' : 2.0})
-    ax.plot(plt_freqs, plt_powers, **plot_kwargs)
 
-    check_n_style(plot_style, ax, log_freqs, log_powers)
+    # Make inputs iterable if need to be passed multiple times to plot each spectrum
+    plt_powers = np.reshape(power_spectra, (1, -1)) if np.ndim(power_spectra) == 1 else \
+        power_spectra
+    plt_freqs = repeat(freqs) if isinstance(freqs, np.ndarray) and freqs.ndim == 1 else freqs
 
+    # Set labels
+    labels = plot_kwargs.pop('label') if 'label' in plot_kwargs.keys() and labels is None else labels
+    labels = repeat(labels) if not isinstance(labels, list) else cycle(labels)
+    colors = repeat(colors) if not isinstance(colors, list) else cycle(colors)
 
-@check_dependency(plt, 'matplotlib')
-def plot_spectra(freqs, power_spectra, log_freqs=False, log_powers=False, labels=None,
-                 ax=None, plot_style=style_spectrum_plot, **plot_kwargs):
-    """Plot multiple power spectra on the same plot.
+    # Plot
+    for freqs, powers, color, label in zip(plt_freqs, plt_powers, colors, labels):
 
-    Parameters
-    ----------
-    freqs : 2d array or 1d array or list of 1d array
-        Frequency values, to be plotted on the x-axis.
-    power_spectra : 2d array or list of 1d array
-        Power values, to be plotted on the y-axis.
-    log_freqs : bool, optional, default: False
-        Whether to plot the frequency axis in log spacing.
-    log_powers : bool, optional, default: False
-        Whether to plot the power axis in log spacing.
-    labels : list of str, optional
-        Legend labels, for each power spectrum.
-    ax : matplotlib.Axes, optional
-        Figure axes upon which to plot.
-    plot_style : callable, optional, default: style_spectrum_plot
-        A function to call to apply styling & aesthetics to the plot.
-    **plot_kwargs
-        Keyword arguments to be passed to the plot call.
-    """
-
-    ax = check_ax(ax, plot_kwargs.pop('figsize', PLT_FIGSIZES['spectral']))
-
-    # Make inputs iterable if need to be passed multiple times to plot each spectrum
-    freqs = repeat(freqs) if isinstance(freqs, np.ndarray) and freqs.ndim == 1 else freqs
-    labels = repeat(labels) if not isinstance(labels, list) else labels
+        # Set plot data, logging if requested, and collect color, if absent
+        freqs = np.log10(freqs) if log_freqs else freqs
+        powers = np.log10(powers) if log_powers else powers
+        if color:
+            plot_kwargs['color'] = color
 
-    for freq, power_spectrum, label in zip(freqs, power_spectra, labels):
-        plot_spectrum(freq, power_spectrum, log_freqs, log_powers, label=label,
-                      plot_style=None, ax=ax, **plot_kwargs)
+        ax.plot(freqs, powers, label=label, **plot_kwargs)
 
-    check_n_style(plot_style, ax, log_freqs, log_powers)
+    style_spectrum_plot(ax, log_freqs, log_powers)
 
 
+@savefig
 @check_dependency(plt, 'matplotlib')
-def plot_spectrum_shading(freqs, power_spectrum, shades, shade_colors='r', add_center=False,
-                          ax=None, plot_style=style_spectrum_plot, **plot_kwargs):
-    """Plot a power spectrum with a shaded frequency region (or regions).
+def plot_spectra_shading(freqs, power_spectra, shades, shade_colors='r',
+                         add_center=False, ax=None, **plot_kwargs):
+    """Plot one or multiple power spectra with a shaded frequency region (or regions).
 
     Parameters
     ----------
-    freqs : 1d array
+    freqs : 1d or 2d array or list of 1d array
         Frequency values, to be plotted on the x-axis.
-    power_spectrum : 1d array
+    power_spectra : 1d or 2d array or list of 1d array
         Power values, to be plotted on the y-axis.
     shades : list of [float, float] or list of list of [float, float]
         Shaded region(s) to add to plot, defined as [lower_bound, upper_bound].
@@ -112,60 +97,98 @@ def plot_spectrum_shading(freqs, power_spectrum, shades, shade_colors='r', add_c
         Whether to add a line at the center point of the shaded regions.
     ax : matplotlib.Axes, optional
         Figure axes upon which to plot.
-    plot_style : callable, optional, default: style_spectrum_plot
-        A function to call to apply styling & aesthetics to the plot.
     **plot_kwargs
-        Keyword arguments to be passed to the plot call.
+        Keyword arguments to pass into :func:`~.plot_spectra`.
+
+    Notes
+    -----
+    Parameters for `plot_spectra` can also be passed into this function as keyword arguments.
+
+    This includes `log_freqs`, `log_powers` & `labels`. See `plot_spectra` for usage details.
     """
 
     ax = check_ax(ax, plot_kwargs.pop('figsize', PLT_FIGSIZES['spectral']))
 
-    plot_spectrum(freqs, power_spectrum, plot_style=None, ax=ax, **plot_kwargs)
+    plot_spectra(freqs, power_spectra, ax=ax, **plot_kwargs)
 
     add_shades(ax, shades, shade_colors, add_center, plot_kwargs.get('log_freqs', False))
 
-    check_n_style(plot_style, ax,
-                  plot_kwargs.get('log_freqs', False),
-                  plot_kwargs.get('log_powers', False))
+    style_spectrum_plot(ax, plot_kwargs.get('log_freqs', False),
+                        plot_kwargs.get('log_powers', False))
 
 
+@savefig
+@style_plot
 @check_dependency(plt, 'matplotlib')
-def plot_spectra_shading(freqs, power_spectra, shades, shade_colors='r', add_center=False,
-                         ax=None, plot_style=style_spectrum_plot, **plot_kwargs):
-    """Plot a group of power spectra with a shaded frequency region (or regions).
+def plot_spectra_yshade(freqs, power_spectra, shade='std', average='mean', scale=1,
+                        log_freqs=False, log_powers=False, color=None, label=None,
+                        ax=None, **plot_kwargs):
+    """Plot standard deviation or error as a shaded region around the mean spectrum.
 
     Parameters
     ----------
-    freqs : 2d array or 1d array or list of 1d array
+    freqs : 1d array
         Frequency values, to be plotted on the x-axis.
-    power_spectra : 2d array or list of 1d array
-        Power values, to be plotted on the y-axis.
-    shades : list of [float, float] or list of list of [float, float]
-        Shaded region(s) to add to plot, defined as [lower_bound, upper_bound].
-    shade_colors : str or list of string
-        Color(s) to plot shades.
-    add_center : bool, optional, default: False
-        Whether to add a line at the center point of the shaded regions.
+    power_spectra : 1d or 2d array
+        Power values, to be plotted on the y-axis. ``shade`` must be provided if 1d.
+    shade : 'std', 'sem', 1d array or callable, optional, default: 'std'
+        Approach for shading above/below the mean spectrum.
+    average : 'mean', 'median' or callable, optional, default: 'mean'
+        Averaging approach for the average spectrum to plot. Only used if power_spectra is 2d.
+    scale : int, optional, default: 1
+        Factor to multiply the plotted shade by.
+    log_freqs : bool, optional, default: False
+        Whether to plot the frequency axis in log spacing.
+    log_powers : bool, optional, default: False
+        Whether to plot the power axis in log spacing.
+    color : str, optional, default: None
+        Line color of the spectrum.
+    label : str, optional, default: None
+        Legend label for the spectrum.
     ax : matplotlib.Axes, optional
         Figure axes upon which to plot.
-    plot_style : callable, optional, default: style_spectrum_plot
-        A function to call to apply styling & aesthetics to the plot.
     **plot_kwargs
         Keyword arguments to be passed to `plot_spectra` or to the plot call.
-
-    Notes
-    -----
-    Parameters for `plot_spectra` can also be passed into this function as keyword arguments.
-
-    This includes `log_freqs`, `log_powers` & `labels`. See `plot_spectra` for usage details.
     """
 
+    if (isinstance(shade, str) or isfunction(shade)) and power_spectra.ndim != 2:
+        raise ValueError('Power spectra must be 2d if shade is not given.')
+
     ax = check_ax(ax, plot_kwargs.pop('figsize', PLT_FIGSIZES['spectral']))
 
-    plot_spectra(freqs, power_spectra, ax=ax, plot_style=None, **plot_kwargs)
+    # Set plot data & labels, logging if requested
+    plt_freqs = np.log10(freqs) if log_freqs else freqs
+    plt_powers = np.log10(power_spectra) if log_powers else power_spectra
+
+    # Organize mean spectrum to plot
+    avg_funcs = {'mean' : np.mean, 'median' : np.median}
 
-    add_shades(ax, shades, shade_colors, add_center, plot_kwargs.get('log_freqs', False))
+    if isinstance(average, str) and plt_powers.ndim == 2:
+        avg_powers = avg_funcs[average](plt_powers, axis=0)
+    elif isfunction(average) and plt_powers.ndim == 2:
+        avg_powers = average(plt_powers)
+    else:
+        avg_powers = plt_powers
+
+    # Plot average power spectrum
+    ax.plot(plt_freqs, avg_powers, linewidth=2.0, color=color, label=label)
+
+    # Organize shading to plot
+    shade_funcs = {'std' : np.std, 'sem' : sem}
+
+    if isinstance(shade, str):
+        shade_vals = scale * shade_funcs[shade](plt_powers, axis=0)
+    elif isfunction(shade):
+        shade_vals = scale * shade(plt_powers)
+    else:
+        shade_vals = scale * shade
+
+    upper_shade = avg_powers + shade_vals
+    lower_shade = avg_powers - shade_vals
+
+    # Plot +/- yshading around spectrum
+    alpha = plot_kwargs.pop('alpha', 0.25)
+    ax.fill_between(plt_freqs, lower_shade, upper_shade,
+                    alpha=alpha, color=color, **plot_kwargs)
 
-    check_n_style(plot_style, ax,
-                  plot_kwargs.get('log_freqs', False),
-                  plot_kwargs.get('log_powers', False))
+    style_spectrum_plot(ax, log_freqs, log_powers)
diff --git a/fooof/plts/style.py b/fooof/plts/style.py
index f9dbcfe..dc72a11 100644
--- a/fooof/plts/style.py
+++ b/fooof/plts/style.py
@@ -1,22 +1,16 @@
 """Style and aesthetics definitions for plots."""
 
-###################################################################################################
-###################################################################################################
+from itertools import cycle
+from functools import wraps
 
-def check_n_style(style_func, *args):
-    """"Check if a style function has been passed, and apply it to a plot if so.
+import matplotlib.pyplot as plt
 
-    Parameters
-    ----------
-    style_func : callable or None
-        Function to apply styling to a plot axis.
-    *args
-        Inputs to the style plot.
-    """
-
-    if style_func:
-        style_func(*args)
+from fooof.plts.settings import (AXIS_STYLE_ARGS, LINE_STYLE_ARGS, COLLECTION_STYLE_ARGS,
+                                 CUSTOM_STYLE_ARGS, STYLE_ARGS, LABEL_SIZE, LEGEND_SIZE,
+                                 LEGEND_LOC, TICK_LABELSIZE, TITLE_FONTSIZE)
 
+###################################################################################################
+###################################################################################################
 
 def style_spectrum_plot(ax, log_freqs, log_powers):
     """Apply style and aesthetics to a power spectrum plot.
@@ -75,3 +69,184 @@ def style_param_plot(ax):
         legend = ax.legend(prop={'size': 16})
         for handle in legend.legendHandles:
             handle._sizes = [100]
+
+
+def apply_axis_style(ax, style_args=AXIS_STYLE_ARGS, **kwargs):
+    """Apply axis plot style.
+
+    Parameters
+    ----------
+    ax : matplotlib.Axes
+        Figure axes to apply style to.
+    style_args : list of str
+        A list of arguments to be sub-selected from `kwargs` and applied as axis styling.
+    **kwargs
+        Keyword arguments that define plot style to apply.
+    """
+
+    # Apply any provided axis style arguments
+    plot_kwargs = {key : val for key, val in kwargs.items() if key in style_args}
+    ax.set(**plot_kwargs)
+
+
+def apply_line_style(ax, style_args=LINE_STYLE_ARGS, **kwargs):
+    """Apply line plot style.
+
+    Parameters
+    ----------
+    ax : matplotlib.Axes
+        Figure axes to apply style to.
+    style_args : list of str
+        A list of arguments to be sub-selected from `kwargs` and applied as line styling.
+    **kwargs
+        Keyword arguments that define line style to apply.
+    """
+
+    # Check how many lines are from the current plot call, to apply style to
+    #   If available, this indicates the apply styling to the last 'n' lines
+    n_lines_apply = kwargs.pop('n_lines_apply', 0)
+
+    # Get the line related styling arguments from the keyword arguments
+    line_kwargs = {key : val for key, val in kwargs.items() if key in style_args}
+
+    # Apply any provided line style arguments
+    for style, value in line_kwargs.items():
+
+        # Values should be either a single value, for all lines, or a list, of a value per line
+        #   This line checks type, and makes a cycle-able / loop-able object out of the values
+        values = cycle([value] if isinstance(value, (int, float, str)) else value)
+        for line in ax.lines[-n_lines_apply:]:
+            line.set(**{style : next(values)})
+
+
+def apply_collection_style(ax, style_args=COLLECTION_STYLE_ARGS, **kwargs):
+    """Apply collection plot style.
+
+    Parameters
+    ----------
+    ax : matplotlib.Axes
+        Figure axes to apply style to.
+    style_args : list of str
+        A list of arguments to be sub-selected from `kwargs` and applied as collection styling.
+    **kwargs
+        Keyword arguments that define collection style to apply.
+    """
+
+    # Get the collection related styling arguments from the keyword arguments
+    collection_kwargs = {key : val for key, val in kwargs.items() if key in style_args}
+
+    # Apply any provided collection style arguments
+    for collection in ax.collections:
+        collection.set(**collection_kwargs)
+
+
+def apply_custom_style(ax, **kwargs):
+    """Apply custom plot style.
+
+    Parameters
+    ----------
+    ax : matplotlib.Axes
+        Figure axes to apply style to.
+    **kwargs
+        Keyword arguments that define custom style to apply.
+    """
+
+    # If a title was provided, update the size
+    if ax.get_title():
+        ax.title.set_size(kwargs.pop('title_fontsize', TITLE_FONTSIZE))
+
+    # Settings for the axis labels
+    label_size = kwargs.pop('label_size', LABEL_SIZE)
+    ax.xaxis.label.set_size(label_size)
+    ax.yaxis.label.set_size(label_size)
+
+    # Settings for the axis ticks
+    ax.tick_params(axis='both', which='major',
+                   labelsize=kwargs.pop('tick_labelsize', TICK_LABELSIZE))
+
+    # If labels were provided, add a legend
+    if ax.get_legend_handles_labels()[0]:
+        ax.legend(prop={'size': kwargs.pop('legend_size', LEGEND_SIZE)},
+                  loc=kwargs.pop('legend_loc', LEGEND_LOC))
+
+    plt.tight_layout()
+
+
+def apply_style(ax, axis_styler=apply_axis_style, line_styler=apply_line_style,
+                collection_styler=apply_collection_style, custom_styler=apply_custom_style,
+                **kwargs):
+    """Apply plot style to a figure axis.
+
+    Parameters
+    ----------
+    ax : matplotlib.Axes
+        Figure axes to apply style to.
+    axis_styler, line_styler, collection_style, custom_styler : callable, optional
+        Functions to apply style to aspects of the plot.
+    **kwargs
+        Keyword arguments that define style to apply.
+
+    Notes
+    -----
+    This function wraps sub-functions which apply style to different plot elements.
+    Each of these sub-functions can be replaced by passing in replacement callables.
+    """
+
+    axis_styler(ax, **kwargs)
+    line_styler(ax, **kwargs)
+    collection_styler(ax, **kwargs)
+    custom_styler(ax, **kwargs)
+
+
+def style_plot(func, *args, **kwargs):
+    """Decorator function to apply a plot style function, after plot generation.
+
+    Parameters
+    ----------
+    func : callable
+        The plotting function for creating a plot.
+    *args, **kwargs
+        Arguments & keyword arguments.
+        These should include any arguments for the plot, and those for applying plot style.
+
+    Notes
+    -----
+    This decorator works by:
+
+    - catching all inputs that relate to plot style
+    - creating a plot, using the passed in plotting function & passing in all non-style arguments
+    - passing the style related arguments into a `apply_style` function which applies plot styling
+
+    By default, this function applies styling with the `apply_style` function. Custom
+    functions for applying style can be passed in using `apply_style` as a keyword argument.
+
+    The `apply_style` function calls sub-functions for applying style different plot elements,
+    and these sub-functions can be overridden by passing in alternatives for `axis_styler`,
+    `line_styler`, and `custom_styler`.
+    """
+
+    @wraps(func)
+    def decorated(*args, **kwargs):
+
+        # Grab a custom style function, if provided, and grab any provided style arguments
+        style_func = kwargs.pop('plot_style', apply_style)
+        style_args = kwargs.pop('style_args', STYLE_ARGS)
+        style_kwargs = {key : kwargs.pop(key) for key in style_args if key in kwargs}
+
+        # Check how many lines are already on the plot, if it exists already
+        n_lines_pre = len(kwargs['ax'].lines) if 'ax' in kwargs and kwargs['ax'] is not None else 0
+
+        # Create the plot
+        func(*args, **kwargs)
+
+        # Get plot axis, if a specific one was provided, or if not, grab the current axis
+        cur_ax = kwargs['ax'] if 'ax' in kwargs and kwargs['ax'] is not None else plt.gca()
+
+        # Check how many lines were added to the plot, and make info available to plot styling
+        n_lines_apply = len(cur_ax.lines) - n_lines_pre
+        style_kwargs['n_lines_apply'] = n_lines_apply
+
+        # Apply the styling function
+        style_func(cur_ax, **style_kwargs)
+
+    return decorated
diff --git a/fooof/plts/utils.py b/fooof/plts/utils.py
index ef5b539..a09c887 100644
--- a/fooof/plts/utils.py
+++ b/fooof/plts/utils.py
@@ -8,9 +8,11 @@ They are not expected to be called directly by the user.
 
 from itertools import repeat
 from collections.abc import Iterator
+from functools import wraps
 
 import numpy as np
 
+from fooof.core.io import fname, fpath
 from fooof.core.modutils import safe_import
 from fooof.core.utils import resolve_aliases
 from fooof.plts.settings import PLT_ALPHA_LEVELS, PLT_ALIASES
@@ -171,3 +173,54 @@ def check_plot_kwargs(plot_kwargs, defaults):
             plot_kwargs[key] = value
 
     return plot_kwargs
+
+
+def savefig(func):
+    """Decorator function to save out figures."""
+
+    @wraps(func)
+    def decorated(*args, **kwargs):
+
+        # Grab file name and path arguments, if they are in kwargs
+        file_name = kwargs.pop('file_name', None)
+        file_path = kwargs.pop('file_path', None)
+
+        # Check for an explicit argument for whether to save figure or not
+        #   Defaults to saving when file name given (since bool(str)->True; bool(None)->False)
+        save_fig = kwargs.pop('save_fig', bool(file_name))
+
+        # Check any collect any other plot keywords
+        save_kwargs = kwargs.pop('save_kwargs', {})
+        save_kwargs.setdefault('bbox_inches', 'tight')
+
+        # Check and collect whether to close the plot
+        close = kwargs.pop('close', None)
+
+        func(*args, **kwargs)
+
+        if save_fig:
+            save_figure(file_name, file_path, close, **save_kwargs)
+
+    return decorated
+
+
+def save_figure(file_name, file_path=None, close=False, **save_kwargs):
+    """Save out a figure.
+
+    Parameters
+    ----------
+    file_name : str
+        File name for the figure file to save out.
+    file_path : str or Path
+        Path for where to save out the figure to.
+    close : bool, optional, default: False
+        Whether to close the plot after saving.
+    save_kwargs
+        Additional arguments to pass into the save function.
+    """
+
+    full_path = fpath(file_path, fname(file_name, 'png'))
+    plt.savefig(full_path, **save_kwargs)
+
+    if close:
+        plt.close()
diff --git a/fooof/sim/gen.py b/fooof/sim/gen.py
index 33c8731..70806cf 100644
--- a/fooof/sim/gen.py
+++ b/fooof/sim/gen.py
@@ -299,7 +299,7 @@ def gen_aperiodic(freqs, aperiodic_params, aperiodic_mode=None):
         Frequency vector to create aperiodic component for.
     aperiodic_params : list of float
         Parameters that define the aperiodic component.
-    aperiodic_mode : {'fixed', 'knee'}, optional
+    aperiodic_mode : {'fixed', 'knee', 'lorentzian'}, optional
         Which kind of aperiodic component to generate.
         If not provided, is inferred from the parameters.
 
@@ -442,7 +442,7 @@ def gen_rotated_power_vals(freqs, aperiodic_params, periodic_params, nlv, f_rota
     return powers
 
 
-def gen_model(freqs, aperiodic_params, periodic_params, return_components=False):
+def gen_model(freqs, aperiodic_params, aperiodic_mode, periodic_params, return_components=False):
     """Generate a power spectrum model for a given parameter definition.
 
     Parameters
@@ -475,7 +475,7 @@ def gen_model(freqs, aperiodic_params, periodic_params, return_components=False)
     - Returns the power spectrum in log10 spacing, as is used in FOOOF models.
     """
 
-    ap_fit = gen_aperiodic(freqs, aperiodic_params)
+    ap_fit = gen_aperiodic(freqs, aperiodic_params, aperiodic_mode)
     pe_fit = gen_periodic(freqs, np.ndarray.flatten(periodic_params))
     full_model = pe_fit + ap_fit
 
diff --git a/fooof/tests/bands/test_bands.py b/fooof/tests/bands/test_bands.py
index 7741213..0b308b0 100644
--- a/fooof/tests/bands/test_bands.py
+++ b/fooof/tests/bands/test_bands.py
@@ -1,6 +1,6 @@
 """Test functions for fooof.data.bands."""
 
-from py.test import raises
+from pytest import raises
 
 from fooof.bands.bands import *
 
diff --git a/fooof/tests/conftest.py b/fooof/tests/conftest.py
index 65a8b00..4d16f4e 100644
--- a/fooof/tests/conftest.py
+++ b/fooof/tests/conftest.py
@@ -8,8 +8,9 @@ import numpy as np
 
 from fooof.core.modutils import safe_import
 
-from fooof.tests.tutils import get_tfm, get_tfg, get_tbands
-from fooof.tests.settings import BASE_TEST_FILE_PATH, TEST_DATA_PATH, TEST_REPORTS_PATH
+from fooof.tests.tutils import get_tfm, get_tfg, get_tbands, get_tresults
+from fooof.tests.settings import (BASE_TEST_FILE_PATH, TEST_DATA_PATH,
+                                  TEST_REPORTS_PATH, TEST_PLOTS_PATH)
 
 plt = safe_import('.pyplot', 'matplotlib')
 
@@ -33,6 +34,7 @@ def check_dir():
     os.mkdir(BASE_TEST_FILE_PATH)
     os.mkdir(TEST_DATA_PATH)
     os.mkdir(TEST_REPORTS_PATH)
+    os.mkdir(TEST_PLOTS_PATH)
 
 @pytest.fixture(scope='session')
 def tfm():
@@ -46,7 +48,16 @@ def tfg():
 def tbands():
     yield get_tbands()
 
+@pytest.fixture(scope='session')
+def tresults():
+    yield get_tresults()
+
 @pytest.fixture(scope='session')
 def skip_if_no_mpl():
     if not safe_import('matplotlib'):
         pytest.skip('Matplotlib not available: skipping test.')
+
+@pytest.fixture(scope='session')
+def skip_if_no_pandas():
+    if not safe_import('pandas'):
+        pytest.skip('Pandas not available: skipping test.')
diff --git a/fooof/tests/core/test_funcs.py b/fooof/tests/core/test_funcs.py
index f9e05dc..4a64503 100644
--- a/fooof/tests/core/test_funcs.py
+++ b/fooof/tests/core/test_funcs.py
@@ -1,6 +1,6 @@
 """Tests for fooof.core.funcs."""
 
-from py.test import raises
+from pytest import raises
 
 import numpy as np
 from scipy.stats import norm, linregress
diff --git a/fooof/tests/core/test_modutils.py b/fooof/tests/core/test_modutils.py
index 047d5c0..f6d9bcc 100644
--- a/fooof/tests/core/test_modutils.py
+++ b/fooof/tests/core/test_modutils.py
@@ -1,8 +1,10 @@
 """Tests for fooof.core.modutils.
 
-Note: decorators (that are in modutils) are currently not tested.
+Note: the decorators for copying documentation are not currently tested.
 """
 
+from pytest import raises
+
 from fooof.core.modutils import *
 
 ###################################################################################################
@@ -16,6 +18,21 @@ def test_safe_import():
     bad = safe_import('bad')
     assert not bad
 
+def test_check_dependency():
+
+    import numpy as np
+    @check_dependency(np, 'numpy')
+    def subfunc_good():
+        pass
+    subfunc_good()
+
+    bad = None
+    @check_dependency(bad, 'bad')
+    def subfunc_bad():
+        pass
+    with raises(ImportError):
+        subfunc_bad()
+
 def test_docs_drop_param():
 
     ds = """STUFF
diff --git a/fooof/tests/core/test_utils.py b/fooof/tests/core/test_utils.py
index 690b492..2dbce06 100644
--- a/fooof/tests/core/test_utils.py
+++ b/fooof/tests/core/test_utils.py
@@ -5,7 +5,7 @@ from itertools import repeat
 
 from numpy import array_equal
 
-from py.test import raises
+from pytest import raises
 
 from fooof.core.utils import *
 
diff --git a/fooof/tests/data/test_conversions.py b/fooof/tests/data/test_conversions.py
new file mode 100644
index 0000000..08ab30b
--- /dev/null
+++ b/fooof/tests/data/test_conversions.py
@@ -0,0 +1,53 @@
+"""Tests for the fooof.data.conversions."""
+
+from copy import deepcopy
+
+import numpy as np
+
+from fooof.core.modutils import safe_import
+pd = safe_import('pandas')
+
+from fooof.data.conversions import *
+
+###################################################################################################
+###################################################################################################
+
+def test_model_to_dict(tresults, tbands):
+
+    out = model_to_dict(tresults, peak_org=1)
+    assert isinstance(out, dict)
+    assert 'cf_0' in out
+    assert out['cf_0'] == tresults.peak_params[0, 0]
+    assert not 'cf_1' in out
+
+    out = model_to_dict(tresults, peak_org=2)
+    assert 'cf_0' in out
+    assert 'cf_1' in out
+    assert out['cf_1'] == tresults.peak_params[1, 0]
+
+    out = model_to_dict(tresults, peak_org=3)
+    assert 'cf_2' in out
+    assert np.isnan(out['cf_2'])
+
+    out = model_to_dict(tresults, peak_org=tbands)
+    assert 'alpha_cf' in out
+
+def test_model_to_dataframe(tresults, tbands, skip_if_no_pandas):
+
+    for peak_org in [1, 2, 3]:
+        out = model_to_dataframe(tresults, peak_org=peak_org)
+        assert isinstance(out, pd.Series)
+
+    out = model_to_dataframe(tresults, peak_org=tbands)
+    assert isinstance(out, pd.Series)
+
+def test_group_to_dataframe(tresults,  tbands, skip_if_no_pandas):
+
+    fit_results = [deepcopy(tresults), deepcopy(tresults), deepcopy(tresults)]
+
+    for peak_org in [1, 2, 3]:
+        out = group_to_dataframe(fit_results, peak_org=peak_org)
+        assert isinstance(out, pd.DataFrame)
+
+    out = group_to_dataframe(fit_results, peak_org=tbands)
+    assert isinstance(out, pd.DataFrame)
diff --git a/fooof/tests/objs/test_fit.py b/fooof/tests/objs/test_fit.py
index 70feff0..b812d89 100644
--- a/fooof/tests/objs/test_fit.py
+++ b/fooof/tests/objs/test_fit.py
@@ -7,14 +7,17 @@ They serve rather as 'smoke tests', for if anything fails completely.
 """
 
 import numpy as np
-from py.test import raises
+from pytest import raises
 
 from fooof.core.items import OBJ_DESC
 from fooof.core.errors import FitError
 from fooof.core.utils import group_three
+from fooof.core.modutils import safe_import
+from fooof.core.errors import DataError, NoDataError, InconsistentDataError
 from fooof.sim import gen_freqs, gen_power_spectrum
 from fooof.data import FOOOFSettings, FOOOFMetaData, FOOOFResults
-from fooof.core.errors import DataError, NoDataError, InconsistentDataError
+
+pd = safe_import('pandas')
 
 from fooof.tests.settings import TEST_DATA_PATH
 from fooof.tests.tutils import get_tfm, plot_test
@@ -161,7 +164,11 @@ def test_fooof_checks():
     tfm.fit(xs, ys)
     assert tfm.freqs[0] != 0
 
-    # Check error if there is a post-logging inf or nan
+    # Check error for `check_freqs` - for if there is non-even frequency values
+    with raises(DataError):
+        tfm.fit(np.array([1, 2, 4]), np.array([1, 2, 3]))
+
+    # Check error for `check_data` - for if there is a post-logging inf or nan
     with raises(DataError):  # Double log (1) -> -inf
         tfm.fit(np.array([1, 2, 3]), np.log10(np.array([1, 2, 3])))
     with raises(DataError):  # Log (-1) -> NaN
@@ -187,7 +194,7 @@ def test_fooof_load():
     # Test that settings and data are None
     #   Except for aperiodic mode, which can be inferred from the data
     for setting in OBJ_DESC['settings']:
-        if setting is not 'aperiodic_mode':
+        if setting != 'aperiodic_mode':
             assert getattr(tfm, setting) is None
     assert getattr(tfm, 'power_spectrum') is None
 
@@ -425,3 +432,10 @@ def test_fooof_check_data():
     # Model fitting should execute, but return a null model fit, given the NaNs, without failing
     tfm.fit()
     assert not tfm.has_model
+
+def test_fooof_to_df(tfm, tbands, skip_if_no_pandas):
+
+    df1 = tfm.to_df(2)
+    assert isinstance(df1, pd.Series)
+    df2 = tfm.to_df(tbands)
+    assert isinstance(df2, pd.Series)
diff --git a/fooof/tests/objs/test_group.py b/fooof/tests/objs/test_group.py
index c40c1cb..5f1e23d 100644
--- a/fooof/tests/objs/test_group.py
+++ b/fooof/tests/objs/test_group.py
@@ -6,14 +6,20 @@ The tests here are not strong tests for accuracy.
 They serve rather as 'smoke tests', for if anything fails completely.
 """
 
+import os
+
 import numpy as np
 from numpy.testing import assert_equal
 
-from fooof.data import FOOOFResults
 from fooof.core.items import OBJ_DESC
+from fooof.core.modutils import safe_import
+from fooof.core.errors import DataError, NoDataError, InconsistentDataError
+from fooof.data import FOOOFResults
 from fooof.sim import gen_group_power_spectra
 
-from fooof.tests.settings import TEST_DATA_PATH
+pd = safe_import('pandas')
+
+from fooof.tests.settings import TEST_DATA_PATH, TEST_REPORTS_PATH
 from fooof.tests.tutils import default_group_params, plot_test
 
 from fooof.objs.group import *
@@ -208,6 +214,13 @@ def test_fg_print(tfg):
     tfg.print_results()
     assert True
 
+def test_save_model_report(tfg):
+
+    file_name = 'test_group_model_report'
+    tfg.save_model_report(0, file_name, TEST_REPORTS_PATH)
+
+    assert os.path.exists(os.path.join(TEST_REPORTS_PATH, file_name + '.pdf'))
+
 def test_get_results(tfg):
     """Check get results method."""
 
@@ -247,7 +260,7 @@ def test_fg_load():
     # Test that settings and data are None
     #   Except for aperiodic mode, which can be inferred from the data
     for setting in OBJ_DESC['settings']:
-        if setting is not 'aperiodic_mode':
+        if setting != 'aperiodic_mode':
             assert getattr(tfg, setting) is None
     assert tfg.power_spectra is None
 
@@ -349,3 +362,10 @@ def test_fg_get_group(tfg):
     # Check that the correct results are extracted
     assert [tfg.group_results[ind] for ind in inds1] == nfg1.group_results
     assert [tfg.group_results[ind] for ind in inds2] == nfg2.group_results
+
+def test_fg_to_df(tfg, tbands, skip_if_no_pandas):
+
+    df1 = tfg.to_df(2)
+    assert isinstance(df1, pd.DataFrame)
+    df2 = tfg.to_df(tbands)
+    assert isinstance(df2, pd.DataFrame)
diff --git a/fooof/tests/objs/test_utils.py b/fooof/tests/objs/test_utils.py
index 6af0837..b496c1b 100644
--- a/fooof/tests/objs/test_utils.py
+++ b/fooof/tests/objs/test_utils.py
@@ -1,6 +1,6 @@
 """Test functions for fooof.objs.utils."""
 
-from py.test import raises
+from pytest import raises
 
 import numpy as np
 
@@ -120,13 +120,17 @@ def test_combine_errors(tfm, tfg):
 
 def test_fit_fooof_3d(tfg):
 
-    n_spectra = 2
+    n_groups = 2
+    n_spectra = 3
     xs, ys = gen_group_power_spectra(n_spectra, *default_group_params())
-    ys = np.stack([ys, ys], axis=0)
+    ys = np.stack([ys] * n_groups, axis=0)
+    spectra_shape = np.shape(ys)
 
     tfg = FOOOFGroup()
     fgs = fit_fooof_3d(tfg, xs, ys)
 
-    assert len(fgs) == 2
+    assert len(fgs) == n_groups == spectra_shape[0]
     for fg in fgs:
         assert fg
+        assert len(fg) == n_spectra
+        assert fg.power_spectra.shape == spectra_shape[1:]
diff --git a/fooof/tests/plts/test_annotate.py b/fooof/tests/plts/test_annotate.py
index c096612..84f3848 100644
--- a/fooof/tests/plts/test_annotate.py
+++ b/fooof/tests/plts/test_annotate.py
@@ -3,6 +3,7 @@
 import numpy as np
 
 from fooof.tests.tutils import plot_test
+from fooof.tests.settings import TEST_PLOTS_PATH
 
 from fooof.plts.annotate import *
 
@@ -12,11 +13,13 @@ from fooof.plts.annotate import *
 @plot_test
 def test_plot_annotated_peak_search(tfm, skip_if_no_mpl):
 
-    plot_annotated_peak_search(tfm)
+    plot_annotated_peak_search(tfm, save_fig=True, file_path=TEST_PLOTS_PATH,
+                               file_name='test_plot_annotated_peak_search.png')
 
 @plot_test
 def test_plot_annotated_model(tfm, skip_if_no_mpl):
 
     # Make sure model has been fit & then plot annotated model
     tfm.fit()
-    plot_annotated_model(tfm)
+    plot_annotated_model(tfm, save_fig=True, file_path=TEST_PLOTS_PATH,
+                         file_name='test_plot_annotated_model.png')
diff --git a/fooof/tests/plts/test_aperiodic.py b/fooof/tests/plts/test_aperiodic.py
index 1679078..477b220 100644
--- a/fooof/tests/plts/test_aperiodic.py
+++ b/fooof/tests/plts/test_aperiodic.py
@@ -3,6 +3,7 @@
 import numpy as np
 
 from fooof.tests.tutils import plot_test
+from fooof.tests.settings import TEST_PLOTS_PATH
 
 from fooof.plts.aperiodic import *
 
@@ -21,7 +22,8 @@ def test_plot_aperiodic_params(skip_if_no_mpl):
 
     # Test for 'knee' mode: offset, knee exponent
     aps = np.array([[1, 100, 1], [0.5, 150, 0.5], [2, 200, 2]])
-    plot_aperiodic_params(aps)
+    plot_aperiodic_params(aps, save_fig=True, file_path=TEST_PLOTS_PATH,
+                          file_name='test_plot_aperiodic_params.png')
 
 @plot_test
 def test_plot_aperiodic_fits(skip_if_no_mpl):
@@ -36,4 +38,5 @@ def test_plot_aperiodic_fits(skip_if_no_mpl):
 
     # Test for 'knee' mode: offset, knee exponent
     aps = np.array([[1, 100, 1], [0.5, 150, 0.5], [2, 200, 2]])
-    plot_aperiodic_fits(aps, [1, 50])
+    plot_aperiodic_fits(aps, [1, 50], save_fig=True, file_path=TEST_PLOTS_PATH,
+                        file_name='test_plot_aperiodic_fits.png')
diff --git a/fooof/tests/plts/test_error.py b/fooof/tests/plts/test_error.py
index 2bffbc7..3e8b817 100644
--- a/fooof/tests/plts/test_error.py
+++ b/fooof/tests/plts/test_error.py
@@ -3,6 +3,7 @@
 import numpy as np
 
 from fooof.tests.tutils import plot_test
+from fooof.tests.settings import TEST_PLOTS_PATH
 
 from fooof.plts.error import *
 
@@ -15,4 +16,5 @@ def test_plot_spectral_error(skip_if_no_mpl):
     fs = np.arange(3, 41, 1)
     errs = np.ones(len(fs))
 
-    plot_spectral_error(fs, errs)
+    plot_spectral_error(fs, errs, save_fig=True, file_path=TEST_PLOTS_PATH,
+                        file_name='test_plot_spectral_error.png')
diff --git a/fooof/tests/plts/test_fg.py b/fooof/tests/plts/test_fg.py
index 8841c9f..bde3a31 100644
--- a/fooof/tests/plts/test_fg.py
+++ b/fooof/tests/plts/test_fg.py
@@ -1,11 +1,12 @@
 """Tests for fooof.plts.fg."""
 
-from py.test import raises
+from pytest import raises
 
 from fooof import FOOOFGroup
 from fooof.core.errors import NoModelError
 
 from fooof.tests.tutils import plot_test
+from fooof.tests.settings import TEST_PLOTS_PATH
 
 from fooof.plts.fg import *
 
@@ -15,7 +16,8 @@ from fooof.plts.fg import *
 @plot_test
 def test_plot_fg(tfg, skip_if_no_mpl):
 
-    plot_fg(tfg)
+    plot_fg(tfg, save_fig=True, file_path=TEST_PLOTS_PATH,
+            file_name='test_plot_fg.png')
 
     # Test error if no data available to plot
     tfg = FOOOFGroup()
@@ -25,14 +27,17 @@ def test_plot_fg(tfg, skip_if_no_mpl):
 @plot_test
 def test_plot_fg_ap(tfg, skip_if_no_mpl):
 
-    plot_fg_ap(tfg)
+    plot_fg_ap(tfg, save_fig=True, file_path=TEST_PLOTS_PATH,
+               file_name='test_plot_fg_ap.png')
 
 @plot_test
 def test_plot_fg_gf(tfg, skip_if_no_mpl):
 
-    plot_fg_gf(tfg)
+    plot_fg_gf(tfg, save_fig=True, file_path=TEST_PLOTS_PATH,
+               file_name='test_plot_fg_gf.png')
 
 @plot_test
 def test_plot_fg_peak_cens(tfg, skip_if_no_mpl):
 
-    plot_fg_peak_cens(tfg)
+    plot_fg_peak_cens(tfg, save_fig=True, file_path=TEST_PLOTS_PATH,
+                      file_name='test_plot_fg_peak_cens.png')
diff --git a/fooof/tests/plts/test_fm.py b/fooof/tests/plts/test_fm.py
index 7fce65a..6d7a0f0 100644
--- a/fooof/tests/plts/test_fm.py
+++ b/fooof/tests/plts/test_fm.py
@@ -1,6 +1,7 @@
 """Tests for fooof.plts.fm."""
 
 from fooof.tests.tutils import plot_test
+from fooof.tests.settings import TEST_PLOTS_PATH
 
 from fooof.plts.fm import *
 
@@ -13,7 +14,8 @@ def test_plot_fm(tfm, skip_if_no_mpl):
     # Make sure model has been fit
     tfm.fit()
 
-    plot_fm(tfm)
+    plot_fm(tfm, save_fig=True, file_path=TEST_PLOTS_PATH,
+            file_name='test_plot_fm.png')
 
 @plot_test
 def test_plot_fm_add_peaks(tfm, skip_if_no_mpl):
@@ -22,9 +24,7 @@ def test_plot_fm_add_peaks(tfm, skip_if_no_mpl):
     tfm.fit()
 
     # Test run each of the add peak approaches
-    for add_peak in ['shade', 'dot', 'outline', 'line']:
-        plot_fm(tfm, plot_peaks=add_peak)
-
-    # Test run some combinations
-    for add_peak in ['shade-dot', 'outline-line']:
-        plot_fm(tfm, plot_peaks=add_peak)
+    for add_peak in ['shade', 'dot', 'outline', 'line', 'shade-dot', 'outline-line']:
+        file_name = 'test_plot_fm_add_peaks_' + add_peak + '.png'
+        plot_fm(tfm, plot_peaks=add_peak, save_fig=True,
+                file_path=TEST_PLOTS_PATH, file_name=file_name)
diff --git a/fooof/tests/plts/test_periodic.py b/fooof/tests/plts/test_periodic.py
index 647c967..83e77da 100644
--- a/fooof/tests/plts/test_periodic.py
+++ b/fooof/tests/plts/test_periodic.py
@@ -3,6 +3,7 @@
 import numpy as np
 
 from fooof.tests.tutils import plot_test
+from fooof.tests.settings import TEST_PLOTS_PATH
 
 from fooof.plts.periodic import *
 
@@ -18,7 +19,8 @@ def test_plot_peak_params(skip_if_no_mpl):
     plot_peak_params(peaks)
 
     # Test with multiple set of params
-    plot_peak_params([peaks, peaks])
+    plot_peak_params([peaks, peaks], save_fig=True, file_path=TEST_PLOTS_PATH,
+                     file_name='test_plot_peak_params.png')
 
 @plot_test
 def test_plot_peak_fits(skip_if_no_mpl):
@@ -29,4 +31,5 @@ def test_plot_peak_fits(skip_if_no_mpl):
     plot_peak_fits(peaks)
 
     # Test with multiple set of params
-    plot_peak_fits([peaks, peaks])
+    plot_peak_fits([peaks, peaks], save_fig=True, file_path=TEST_PLOTS_PATH,
+                   file_name='test_plot_peak_fits.png')
diff --git a/fooof/tests/plts/test_spectra.py b/fooof/tests/plts/test_spectra.py
index 9abb95b..5ca7dbd 100644
--- a/fooof/tests/plts/test_spectra.py
+++ b/fooof/tests/plts/test_spectra.py
@@ -1,8 +1,11 @@
 """Tests for fooof.plts.spectra."""
 
+from pytest import raises
+
 import numpy as np
 
 from fooof.tests.tutils import plot_test
+from fooof.tests.settings import TEST_PLOTS_PATH
 
 from fooof.plts.spectra import *
 
@@ -10,41 +13,77 @@ from fooof.plts.spectra import *
 ###################################################################################################
 
 @plot_test
-def test_plot_spectrum(tfm, skip_if_no_mpl):
-
-    plot_spectrum(tfm.freqs, tfm.power_spectrum)
-
-    # Test with logging both axes
-    plot_spectrum(tfm.freqs, tfm.power_spectrum, True, True)
+def test_plot_spectra(tfm, tfg, skip_if_no_mpl):
 
-@plot_test
-def test_plot_spectra(tfg, skip_if_no_mpl):
+    # Test with 1d inputs - 1d freq array and list of 1d power spectra
+    plot_spectra(tfm.freqs, tfm.power_spectrum,
+                 save_fig=True, file_path=TEST_PLOTS_PATH, file_name='test_plot_spectra_1d.png')
 
     # Test with 1d inputs - 1d freq array and list of 1d power spectra
-    plot_spectra(tfg.freqs, [tfg.power_spectra[0, :], tfg.power_spectra[1, :]])
+    plot_spectra(tfg.freqs, [tfg.power_spectra[0, :], tfg.power_spectra[1, :]],
+                 save_fig=True, file_path=TEST_PLOTS_PATH, file_name='test_plot_spectra_list_1d.png')
 
     # Test with multiple freq inputs - list of 1d freq array and list of 1d power spectra
-    plot_spectra([tfg.freqs, tfg.freqs], [tfg.power_spectra[0, :], tfg.power_spectra[1, :]])
+    plot_spectra([tfg.freqs, tfg.freqs], [tfg.power_spectra[0, :], tfg.power_spectra[1, :]],
+                 save_fig=True, file_path=TEST_PLOTS_PATH,
+                 file_name='test_plot_spectra_lists_1d.png')
 
     # Test with 2d array inputs
     plot_spectra(np.vstack([tfg.freqs, tfg.freqs]),
-                 np.vstack([tfg.power_spectra[0, :], tfg.power_spectra[1, :]]))
+                 np.vstack([tfg.power_spectra[0, :], tfg.power_spectra[1, :]]),
+                 save_fig=True, file_path=TEST_PLOTS_PATH, file_name='test_plot_spectra_2d.png')
 
     # Test with labels
-    plot_spectra(tfg.freqs, [tfg.power_spectra[0, :], tfg.power_spectra[1, :]], labels=['A', 'B'])
+    plot_spectra(tfg.freqs, [tfg.power_spectra[0, :], tfg.power_spectra[1, :]], labels=['A', 'B'],
+                 save_fig=True, file_path=TEST_PLOTS_PATH, file_name='test_plot_spectra_labels.png')
 
 @plot_test
-def test_plot_spectrum_shading(tfm, skip_if_no_mpl):
+def test_plot_spectra_shading(tfm, tfg, skip_if_no_mpl):
 
-    plot_spectrum_shading(tfm.freqs, tfm.power_spectrum, shades=[8, 12], add_center=True)
-
-@plot_test
-def test_plot_spectra_shading(tfg, skip_if_no_mpl):
+    plot_spectra_shading(tfm.freqs, tfm.power_spectrum, shades=[8, 12], add_center=True,
+                         save_fig=True, file_path=TEST_PLOTS_PATH,
+                         file_name='test_plot_spectrum_shading1.png')
 
     plot_spectra_shading(tfg.freqs, [tfg.power_spectra[0, :], tfg.power_spectra[1, :]],
-                         shades=[8, 12], add_center=True)
+                         shades=[8, 12], add_center=True, save_fig=True, file_path=TEST_PLOTS_PATH,
+                         file_name='test_plot_spectra_shading2.png')
 
     # Test with **kwargs that pass into plot_spectra
     plot_spectra_shading(tfg.freqs, [tfg.power_spectra[0, :], tfg.power_spectra[1, :]],
                          shades=[8, 12], add_center=True, log_freqs=True, log_powers=True,
-                         labels=['A', 'B'])
+                         labels=['A', 'B'], save_fig=True, file_path=TEST_PLOTS_PATH,
+                         file_name='test_plot_spectra_shading_kwargs.png')
+
+@plot_test
+def test_plot_spectra_yshade(skip_if_no_mpl, tfg):
+
+    freqs = tfg.freqs
+    powers = tfg.power_spectra
+
+    # Invalid 1d array, without shade
+    with raises(ValueError):
+        plot_spectra_yshade(freqs, powers[0])
+
+    # Plot with 2d array
+    plot_spectra_yshade(freqs, powers, shade='std',
+                        save_fig=True, file_path=TEST_PLOTS_PATH,
+                        file_name='test_plot_spectra_yshade1.png')
+
+    # Plot shade with given 1d array
+    plot_spectra_yshade(freqs, np.mean(powers, axis=0),
+                        shade=np.std(powers, axis=0),
+                        save_fig=True, file_path=TEST_PLOTS_PATH,
+                        file_name='test_plot_spectra_yshade2.png')
+
+    # Plot shade with different average and shade approaches
+    plot_spectra_yshade(freqs, powers, shade='sem', average='median',
+                        save_fig=True, file_path=TEST_PLOTS_PATH,
+                        file_name='test_plot_spectra_yshade3.png')
+
+    # Plot shade with custom average and shade callables
+    def _average_callable(powers): return np.mean(powers, axis=0)
+    def _shade_callable(powers): return np.std(powers, axis=0)
+
+    plot_spectra_yshade(freqs, powers, shade=_shade_callable,  average=_average_callable,
+                        log_powers=True, save_fig=True, file_path=TEST_PLOTS_PATH,
+                        file_name='test_plot_spectra_yshade4.png')
diff --git a/fooof/tests/plts/test_styles.py b/fooof/tests/plts/test_styles.py
index f1b2f09..72854ff 100644
--- a/fooof/tests/plts/test_styles.py
+++ b/fooof/tests/plts/test_styles.py
@@ -1,20 +1,11 @@
 """Tests for fooof.plts.styles."""
 
+from fooof.tests.tutils import plot_test
 from fooof.plts.style import *
 
 ###################################################################################################
 ###################################################################################################
 
-def test_check_n_style(skip_if_no_mpl):
-
-    # Check can pass None and do nothing
-    check_n_style(None)
-
-    # Check can pass a callable
-    def checker(*args):
-        return True
-    check_n_style(checker)
-
 def test_style_spectrum_plot(skip_if_no_mpl):
 
     # Create a dummy plot and style it
@@ -26,3 +17,88 @@ def test_style_spectrum_plot(skip_if_no_mpl):
     # Check that axis labels are added - use as proxy that it ran correctly
     assert ax.xaxis.get_label().get_text()
     assert ax.yaxis.get_label().get_text()
+
+
+def test_apply_axis_style():
+
+    _, ax = plt.subplots()
+
+    title = 'Ploty McPlotface'
+    xlim = (1.0, 10.0)
+    ylabel = 'Line Value'
+
+    apply_axis_style(ax, title=title, xlim=xlim, ylabel=ylabel)
+
+    assert ax.get_title() == title
+    assert ax.get_xlim() == xlim
+    assert ax.get_ylabel() == ylabel
+
+
+def test_apply_line_style():
+
+    # Check applying style to one line
+    _, ax = plt.subplots()
+    ax.plot([1, 2], [3, 4])
+
+    lw = 4
+    apply_line_style(ax, lw=lw)
+
+    assert ax.get_lines()[0].get_lw() == lw
+
+    # Check applying style across multiple lines
+    _, ax = plt.subplots()
+    ax.plot([1, 2], [[3, 4], [5, 6]])
+
+    alphas = [0.5, 0.75]
+    apply_line_style(ax, alpha=alphas)
+
+    for line, alpha in zip(ax.get_lines(), alphas):
+        assert line.get_alpha() == alpha
+
+
+def test_apply_custom_style():
+
+    _, ax = plt.subplots()
+    ax.set_title('placeholder')
+
+    # Test simple application of custom plot style
+    apply_custom_style(ax)
+    assert ax.title.get_size() == TITLE_FONTSIZE
+
+    # Test adding input parameters to custom plot style
+    new_title_fontsize = 15.0
+    apply_custom_style(ax, title_fontsize=new_title_fontsize)
+    assert ax.title.get_size() == new_title_fontsize
+
+
+def test_apply_style():
+
+    _, ax = plt.subplots()
+
+    def my_custom_styler(ax, **kwargs):
+        ax.set_title('DATA!')
+
+    # Apply plot style using all defaults
+    apply_style(ax)
+
+    # Apply plot style passing in a styler
+    apply_style(ax, custom_styler=my_custom_styler)
+
+
+@plot_test
+def test_style_plot():
+
+    @style_plot
+    def example_plot():
+        plt.plot([1, 2], [3, 4])
+
+    def my_plot_style(ax, **kwargs):
+        ax.set_title('Custom!')
+
+    # Test with applying default custom styling
+    lw = 5
+    title = 'Science.'
+    example_plot(title=title, lw=lw)
+
+    # Test with passing in own plot_style function
+    example_plot(plot_style=my_plot_style)
diff --git a/fooof/tests/plts/test_utils.py b/fooof/tests/plts/test_utils.py
index e7b2c5a..90d4687 100644
--- a/fooof/tests/plts/test_utils.py
+++ b/fooof/tests/plts/test_utils.py
@@ -1,9 +1,12 @@
 """Tests for fooof.plts.utils."""
 
-from fooof.tests.tutils import plot_test
+import os
 
 from fooof.core.modutils import safe_import
 
+from fooof.tests.tutils import plot_test
+from fooof.tests.settings import TEST_PLOTS_PATH
+
 from fooof.plts.utils import *
 
 mpl = safe_import('matplotlib')
@@ -69,3 +72,32 @@ def test_check_plot_kwargs(skip_if_no_mpl):
     assert len(plot_kwargs) == 2
     assert plot_kwargs['alpha'] == 0.5
     assert plot_kwargs['linewidth'] == 2
+
+def test_savefig():
+
+    @savefig
+    def example_plot():
+        plt.plot([1, 2], [3, 4])
+
+    # Test defaults to saving given file path & name
+    example_plot(file_path=TEST_PLOTS_PATH, file_name='test_savefig1.pdf')
+    assert os.path.exists(os.path.join(TEST_PLOTS_PATH, 'test_savefig1.pdf'))
+
+    # Test works the same when explicitly given `save_fig`
+    example_plot(save_fig=True, file_path=TEST_PLOTS_PATH, file_name='test_savefig2.pdf')
+    assert os.path.exists(os.path.join(TEST_PLOTS_PATH, 'test_savefig2.pdf'))
+
+    # Test giving additional save kwargs
+    example_plot(file_path=TEST_PLOTS_PATH, file_name='test_savefig3.pdf',
+                 save_kwargs={'facecolor' : 'red'})
+    assert os.path.exists(os.path.join(TEST_PLOTS_PATH, 'test_savefig3.pdf'))
+
+    # Test does not save when `save_fig` set to False
+    example_plot(save_fig=False, file_path=TEST_PLOTS_PATH, file_name='test_savefig_nope.pdf')
+    assert not os.path.exists(os.path.join(TEST_PLOTS_PATH, 'test_savefig_nope.pdf'))
+
+def test_save_figure():
+
+    plt.plot([1, 2], [3, 4])
+    save_figure(file_name='test_save_figure.pdf', file_path=TEST_PLOTS_PATH)
+    assert os.path.exists(os.path.join(TEST_PLOTS_PATH, 'test_save_figure.pdf'))
diff --git a/fooof/tests/settings.py b/fooof/tests/settings.py
index 9beae1a..856c532 100644
--- a/fooof/tests/settings.py
+++ b/fooof/tests/settings.py
@@ -10,3 +10,4 @@ import pkg_resources as pkg
 BASE_TEST_FILE_PATH = pkg.resource_filename(__name__, 'test_files')
 TEST_DATA_PATH = os.path.join(BASE_TEST_FILE_PATH, 'data')
 TEST_REPORTS_PATH = os.path.join(BASE_TEST_FILE_PATH, 'reports')
+TEST_PLOTS_PATH = os.path.join(BASE_TEST_FILE_PATH, 'plots')
diff --git a/fooof/tests/sim/test_params.py b/fooof/tests/sim/test_params.py
index 983e13c..c8ccb6f 100644
--- a/fooof/tests/sim/test_params.py
+++ b/fooof/tests/sim/test_params.py
@@ -1,6 +1,6 @@
 """Test functions for fooof.sim.params."""
 
-from py.test import raises
+from pytest import raises
 
 from numpy import array_equal
 
diff --git a/fooof/tests/tutils.py b/fooof/tests/tutils.py
index 5103746..3572a35 100644
--- a/fooof/tests/tutils.py
+++ b/fooof/tests/tutils.py
@@ -2,7 +2,10 @@
 
 from functools import wraps
 
+import numpy as np
+
 from fooof.bands import Bands
+from fooof.data import FOOOFResults
 from fooof.objs import FOOOF, FOOOFGroup
 from fooof.core.modutils import safe_import
 from fooof.sim.params import param_sampler
@@ -43,6 +46,14 @@ def get_tbands():
 
     return Bands({'theta' : (4, 8), 'alpha' : (8, 12), 'beta' : (13, 30)})
 
+def get_tresults():
+    """Get a FOOOFResults objet, for testing."""
+
+    return FOOOFResults(aperiodic_params=np.array([1.0, 1.00]),
+                        peak_params=np.array([[10.0, 1.25, 2.0], [20.0, 1.0, 3.0]]),
+                        r_squared=0.97, error=0.01,
+                        gaussian_params=np.array([[10.0, 1.25, 1.0], [20.0, 1.0, 1.5]]))
+
 def default_group_params():
     """Create default parameters for generating a test group of power spectra."""
 
diff --git a/fooof/tests/utils/test_data.py b/fooof/tests/utils/test_data.py
index fb4d7ad..9d91f5a 100644
--- a/fooof/tests/utils/test_data.py
+++ b/fooof/tests/utils/test_data.py
@@ -2,7 +2,7 @@
 
 import numpy as np
 
-from fooof.sim.gen import gen_power_spectrum
+from fooof.sim.gen import gen_power_spectrum, gen_group_power_spectra
 
 from fooof.utils.data import *
 
@@ -21,11 +21,62 @@ def test_trim_spectrum():
 
 def test_interpolate_spectrum():
 
+    # Test with single buffer exclusion zone
     freqs, powers = gen_power_spectrum(\
         [1, 75], [1, 1], [[10, 0.5, 1.0], [60, 2, 0.1]])
 
-    freqs_out, powers_out = interpolate_spectrum(freqs, powers, [58, 62])
+    exclude = [58, 62]
 
+    freqs_out, powers_out = interpolate_spectrum(freqs, powers, exclude)
+
+    assert np.array_equal(freqs, freqs_out)
+    assert np.all(powers)
+    assert powers.shape == powers_out.shape
+    mask = np.logical_and(freqs >= exclude[0], freqs <= exclude[1])
+    assert powers[mask].sum() > powers_out[mask].sum()
+
+    # Test with multiple buffer exclusion zones
+    freqs, powers = gen_power_spectrum(\
+        [1, 150], [1, 100, 1], [[10, 0.5, 1.0], [60, 1, 0.1], [120, 0.5, 0.1]])
+
+    exclude = [[58, 62], [118, 122]]
+
+    freqs_out, powers_out = interpolate_spectrum(freqs, powers, exclude)
     assert np.array_equal(freqs, freqs_out)
     assert np.all(powers)
     assert powers.shape == powers_out.shape
+
+    for f_range in exclude:
+        mask = np.logical_and(freqs >= f_range[0], freqs <= f_range[1])
+        assert powers[mask].sum() > powers_out[mask].sum()
+
+def test_subsample_spectra():
+
+    # Simulate spectra, each with unique osc peak (for checking)
+    n_sim = 10
+    oscs = [[10 + ind, 0.25, 0.5] for ind in range(n_sim)]
+    freqs, powers = gen_group_power_spectra(\
+        n_sim, [1, 50], [1, 1], oscs)
+
+    # Test with int input
+    n_select = 2
+    out = subsample_spectra(powers, n_select)
+    assert isinstance(out, np.ndarray)
+    assert out.shape == (n_select, powers.shape[1])
+
+    # Test with foat input
+    prop_select = 0.75
+    out = subsample_spectra(powers, prop_select)
+    assert isinstance(out, np.ndarray)
+    assert out.shape == (int(prop_select * n_sim), powers.shape[1])
+
+    # Test returning indices
+    out, inds = subsample_spectra(powers, n_select, return_inds=True)
+    assert len(set(inds)) == n_select
+    for ind, spectrum in zip(inds, out):
+        assert np.array_equal(spectrum, powers[ind, :])
+
+    out, inds = subsample_spectra(powers, prop_select, return_inds=True)
+    assert len(set(inds)) == int(prop_select * n_sim)
+    for ind, spectrum in zip(inds, out):
+        assert np.array_equal(spectrum, powers[ind, :])
diff --git a/fooof/utils/__init__.py b/fooof/utils/__init__.py
index 9407c93..4d3775f 100644
--- a/fooof/utils/__init__.py
+++ b/fooof/utils/__init__.py
@@ -1,3 +1,3 @@
 """Utilities sub-module for FOOOF."""
 
-from .data import trim_spectrum, interpolate_spectrum
+from .data import trim_spectrum, interpolate_spectrum, subsample_spectra
diff --git a/fooof/utils/data.py b/fooof/utils/data.py
index 8410b19..5ce8f99 100644
--- a/fooof/utils/data.py
+++ b/fooof/utils/data.py
@@ -1,5 +1,7 @@
 """Utilities for working with data and models."""
 
+from itertools import repeat
+
 import numpy as np
 
 ###################################################################################################
@@ -60,9 +62,10 @@ def interpolate_spectrum(freqs, powers, interp_range, buffer=3):
         Frequency values for the power spectrum.
     powers : 1d array
         Power values for the power spectrum.
-    interp_range : list of float
+    interp_range : list of float or list of list of float
         Frequency range to interpolate, as [lowest_freq, highest_freq].
-    buffer : int
+        If a list of lists, applies each as it's own interpolation range.
+    buffer : int or list of int
         The number of samples to use on either side of the interpolation
         range, that are then averaged and used to calculate the interpolation.
 
@@ -101,23 +104,87 @@ def interpolate_spectrum(freqs, powers, interp_range, buffer=3):
     >>> freqs, powers = interpolate_spectrum(freqs, powers, [58, 62])
     """
 
-    # Get the set of frequency values that need to be interpolated
-    interp_mask = np.logical_and(freqs >= interp_range[0], freqs <= interp_range[1])
-    interp_freqs = freqs[interp_mask]
+    # If given a list of interpolation zones, recurse to apply each one
+    if isinstance(interp_range[0], list):
+        buffer = repeat(buffer) if isinstance(buffer, int) else buffer
+        for interp_zone, cur_buffer in zip(interp_range, buffer):
+            freqs, powers = interpolate_spectrum(freqs, powers, interp_zone, cur_buffer)
+
+    # Assuming list of two floats, interpolate a single frequency range
+    else:
+
+        # Take a copy of the array, to not change original array
+        powers = np.copy(powers)
 
-    # Get the indices of the interpolation range
-    ii1, ii2 = np.flatnonzero(interp_mask)[[0, -1]]
+        # Get the set of frequency values that need to be interpolated
+        interp_mask = np.logical_and(freqs >= interp_range[0], freqs <= interp_range[1])
+        interp_freqs = freqs[interp_mask]
 
-    # Extract & log the requested range of data to use around interpolated range
-    xs1 = np.log10(freqs[ii1-buffer:ii1])
-    xs2 = np.log10(freqs[ii2:ii2+buffer])
-    ys1 = np.log10(powers[ii1-buffer:ii1])
-    ys2 = np.log10(powers[ii2:ii2+buffer])
+        # Get the indices of the interpolation range
+        ii1, ii2 = np.flatnonzero(interp_mask)[[0, -1]]
 
-    # Linearly interpolate, in log-log space, between averages of the extracted points
-    vals = np.interp(np.log10(interp_freqs),
-                     [np.median(xs1), np.median(xs2)],
-                     [np.median(ys1), np.median(ys2)])
-    powers[interp_mask] = np.power(10, vals)
+        # Extract & log the requested range of data to use around interpolated range
+        xs1 = np.log10(freqs[ii1-buffer:ii1])
+        xs2 = np.log10(freqs[ii2:ii2+buffer])
+        ys1 = np.log10(powers[ii1-buffer:ii1])
+        ys2 = np.log10(powers[ii2:ii2+buffer])
+
+        # Linearly interpolate, in log-log space, between averages of the extracted points
+        vals = np.interp(np.log10(interp_freqs),
+                         [np.median(xs1), np.median(xs2)],
+                         [np.median(ys1), np.median(ys2)])
+        powers[interp_mask] = np.power(10, vals)
 
     return freqs, powers
+
+
+def subsample_spectra(spectra, selection, return_inds=False):
+    """Subsample a group of power spectra.
+
+    Parameters
+    ----------
+    spectra : 2d array
+        A group of power spectra to subsample from.
+    selection : int or float
+        The number of spectra to subsample.
+        If int, is the number to select, if float, is a proportion based on input size.
+    return_inds : bool, optional, default: False
+        Whether to return the list of indices that were selected.
+
+    Returns
+    -------
+    subsample : 2d array
+        A subsampled selection of power spectra.
+    inds : list of int
+        A list of which indices where subsampled.
+        Only returned if `return_inds` is True.
+
+    Examples
+    --------
+    Using a group of simulated spectra, subsample a specific number:
+
+    >>> from fooof.sim import gen_group_power_spectra
+    >>> freqs, powers = gen_group_power_spectra(10, [1, 50], [1, 1], [10, 0.5, 1.0])
+    >>> subsample = subsample_spectra(powers, 5)
+
+    Using a group of simulated spectra, subsample a proportion:
+
+    >>> from fooof.sim import gen_group_power_spectra
+    >>> freqs, powers = gen_group_power_spectra(10, [1, 50], [1, 1], [10, 0.5, 1.0])
+    >>> subsample = subsample_spectra(powers, 0.25)
+    """
+
+    n_spectra = spectra.shape[0]
+
+    if isinstance(selection, float):
+        n_sample = int(n_spectra * selection)
+    else:
+        n_sample = selection
+
+    inds = np.random.choice(n_spectra, n_sample, replace=False)
+    subsample = spectra[inds, :]
+
+    if return_inds:
+        return subsample, inds
+    else:
+        return subsample
diff --git a/fooof/utils/download.py b/fooof/utils/download.py
index 2f9f4a7..17cf91f 100644
--- a/fooof/utils/download.py
+++ b/fooof/utils/download.py
@@ -8,7 +8,7 @@ import numpy as np
 ###################################################################################################
 ###################################################################################################
 
-DATA_URL = 'https://raw.githubusercontent.com/fooof-tools/fooof/master/data/'
+DATA_URL = 'https://raw.githubusercontent.com/fooof-tools/fooof/main/data/'
 
 def check_data_folder(folder):
     """Check if a data folder exists, and create if not.
diff --git a/fooof/version.py b/fooof/version.py
index 7cead9e..0731bc6 100644
--- a/fooof/version.py
+++ b/fooof/version.py
@@ -1 +1 @@
-__version__ = '1.0.1-dev'
\ No newline at end of file
+__version__ = '1.1.0rc0'
\ No newline at end of file
